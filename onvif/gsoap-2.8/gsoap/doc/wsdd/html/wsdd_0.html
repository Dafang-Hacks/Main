<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>gSOAP WS-Discovery: The wsdd library for WS-Discovery 1.1 support</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">gSOAP WS-Discovery&#160;<span id="projectnumber">2.8 Stable</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">The wsdd library for WS-Discovery 1.1 support </div>  </div>
</div>
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="wsdd_1"></a>
WS-Discovery Setup</h2>
<p>The material in this section relates to the WS-Discovery specification.</p>
<p>To use the wsdd library:</p>
<ol type="1">
<li>Define WS-Discovery event handlers in your code, see Section <a class="el" href="wsdd_0.html#wsdd_2">WS-Discovery Event Handlers</a>.</li>
<li>Use the wsdd API functions as described below.</li>
<li>(Re-)compile and link stdsoap2.c/pp or libgsoap, (dom.c/.cpp when needed), <a class="el" href="wsddapi_8c.html">wsddapi.c</a>, <a class="el" href="wsaapi_8c.html">wsaapi.c</a> and the soapcpp2-generated source files. Compile and link with plugin/threads.c when needed.</li>
</ol>
<p>The material in this document pertains to the WS-Discovery protocol and model and assumes that the reader is familiar with the WS-Discovery protocol, its terms and definitions, and the WS-Discovery model. This document describes the WS-Discovery interface to invoke and handle WS-Discovery events, while the higher-level logic remains application-specific. Especially the mode of operation, ad-hoc or managed with a Discovery Proxy, depends on the application deployment and WS-Discovery support requirements.</p>
<p>The following assumptions are made. A Client is an endpoint that searches for Target Service(s). A Target Service (TS) is and endpoint that makes itself available for discovery. A Discovery Proxy (DP) is an endpoint that facilitates discovery of Target Services by Clients. The interfaces defined in the wsdd library can be used to implement Client, Target Service, and Discovery Proxy operations.</p>
<p>WS-Discovery ad-hoc and managed modes are supported by the wsdd library. In an ad-hoc mode discovery messages are sent multicast and response messages are sent unicast. In a managed mode discovery messages are sent unicast to a Discovery Proxy.</p>
<h2><a class="anchor" id="wsdd_2"></a>
WS-Discovery Event Handlers</h2>
<p>The following event handlers MUST be defined by the user to handle inbound WS-Discovery messages. The event handlers receive notifications (Hello, Bye, ProbeMatches, and ResolveMatches) or receive requests to provide data (Probe and Resolve).</p>
<p>The event handlers to define are:</p>
<ul>
<li><a class="el" href="wsddapi_8h.html#a24726d40e324bced15ea7c32e8e01de7">wsdd_event_Hello</a></li>
<li><a class="el" href="wsddapi_8h.html#a2741ba2ad6403207601ca2dbd9091e66">wsdd_event_Bye</a></li>
<li><a class="el" href="wsddapi_8h.html#abbabd438789cc445ee72372722e7a6f4">wsdd_event_Probe</a></li>
<li><a class="el" href="wsddapi_8h.html#acbe8ef906112805937c9f19701649ba3">wsdd_event_ProbeMatches</a></li>
<li><a class="el" href="wsddapi_8h.html#aeeb67571da9ca4a2da8730d49cae3021">wsdd_event_Resolve</a></li>
<li><a class="el" href="wsddapi_8h.html#a6fe08bbe8ab19ff2a1e0874c0a104d18">wsdd_event_ResolveMatches</a></li>
</ul>
<p>See the documentation provided with each of these functions in <a class="el" href="wsddapi_8h.html">wsddapi.h</a>.</p>
<h2><a class="anchor" id="wsdd_3"></a>
WS-Discovery Event Listener</h2>
<p>Inbound WS-Discovery multicast messages are handled via a listener on a port. The user-defined event handlers are invoked when WS-Discovery messages arrive on the port.</p>
<p>The <a class="el" href="wsddapi_8c.html#aeaf4e9c91f54ffcf09534b68b5ee6778">soap_wsdd_listen</a> function listens on the current port opened with soap_bind for WS-Discovery messages for a brief time period as specified by a timeout value in seconds (negative for micro seconds). The function allows for periodically polling the port as shown:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &quot;<a class="code" href="wsddapi_8h.html">wsddapi.h</a>&quot;</span>
<span class="keywordtype">int</span> port = 8080;
<span class="keyword">struct </span>soap *soap = soap_new();
soap-&gt;user = (<span class="keywordtype">void</span>*)&amp;my_state;
<span class="keywordflow">if</span> (!soap_valid_socket(soap_bind(soap, port, 100)))
{ soap_print_fault(soap, stderr);
  exit(0);
}

<a class="code" href="wsddapi_8h.html#aeaf4e9c91f54ffcf09534b68b5ee6778" title="Listen on a port for inbound WS-Discovery messages.">soap_wsdd_listen</a>(soap, -1000); <span class="comment">// listen for messages for 1 ms</span>

<a class="code" href="wsddapi_8h.html#aeaf4e9c91f54ffcf09534b68b5ee6778" title="Listen on a port for inbound WS-Discovery messages.">soap_wsdd_listen</a>(soap, -1000); <span class="comment">// listen for messages for 1 ms</span>
...
</pre></div><p>WS-Discovery messages are relayed to the event handlers. The soap-&gt;user pointer can be used to point to a state object that is updated by the event handlers as per desired behavior at the Client side, the Target Service, or the Discovery Proxy implementation.</p>
<h2><a class="anchor" id="wsdd_4"></a>
Invoking WS-Discovery Operations</h2>
<p>A Client may invoke the following WS-Discovery operations:</p>
<ul>
<li><a class="el" href="wsddapi_8c.html#a79d93ab49aba655b6b767b28d0aff6ad">soap_wsdd_Probe</a></li>
<li><a class="el" href="wsddapi_8c.html#acfcc0ff137be16fd9706f21faaeb7b23">soap_wsdd_Resolve</a></li>
</ul>
<p>A Target Service may invoke the following WS-Discovery operations:</p>
<ul>
<li><a class="el" href="wsddapi_8c.html#a4468038ee56dc4709e1550f57dadb0c4">soap_wsdd_Hello</a></li>
<li><a class="el" href="wsddapi_8c.html#a5912eb51290b18adb51cfa80e8c55671">soap_wsdd_Bye</a></li>
<li><a class="el" href="wsddapi_8c.html#ac1fd8fdfb24767d214f68659bfbe4187">soap_wsdd_ProbeMatches</a> (automatic via <a class="el" href="wsddapi_8c.html#aeaf4e9c91f54ffcf09534b68b5ee6778">soap_wsdd_listen</a>)</li>
<li><a class="el" href="wsddapi_8c.html#a6a9722eaaef27e3655714b7592aa3af9">soap_wsdd_ResolveMatches</a> (automatic via <a class="el" href="wsddapi_8c.html#aeaf4e9c91f54ffcf09534b68b5ee6778">soap_wsdd_listen</a>)</li>
</ul>
<p>A Discovery Proxy can perform all operations listed above, and should use "wsdd:DiscoveryProxy" as the Type with the Hello, Bye, and ProbeMatches.</p>
<p>To send a Hello message to join a network:</p>
<div class="fragment"><pre class="fragment"><a class="code" href="wsddapi_8h.html#a4468038ee56dc4709e1550f57dadb0c4" title="TS or DP Hello message to join a network.">soap_wsdd_Hello</a>(soap,
  <a class="code" href="wsddapi_8h.html#a4d8f41b14eeb3500631fd39cad15b4a7a06282f02ad809feed167d23a3cf5ac46">SOAP_WSDD_MANAGED</a>,    <span class="comment">// or SOAP_WSDD_ADHOC for ad-hoc mode</span>
  <span class="stringliteral">&quot;to address&quot;</span>,         <span class="comment">// &quot;http(s):&quot; URL, or &quot;soap.udp:&quot; UDP, or TCP/IP address</span>
  <a class="code" href="wsaapi_8h.html#ac2b81c42093fc9fcadcf86e7d801e03b" title="Generates a random UUID (UUID algorithm version 4). Compile all source codes with -DWITH_OPENSSL for ...">soap_wsa_rand_uuid</a>(soap), <span class="comment">// a unique message ID</span>
  NULL,
  <span class="stringliteral">&quot;my address&quot;</span>,         <span class="comment">// where they can find me for WS-Discovery</span>
  <span class="stringliteral">&quot;wsdd:DiscoveryProxy&quot;</span>,<span class="comment">// Types: I&#39;m a DP</span>
  NULL,                 <span class="comment">// Scope</span>
  NULL,                 <span class="comment">// MatchBy</span>
  NULL,                 <span class="comment">// XAddrs</span>
  75965);               <span class="comment">// MDVersion</span>
</pre></div><p>Note that Types is a string with namespace-qualified names (QNames). These should be qualified as in "namespace":name or you can use a namespace prefix that is part of your namespace table (in the .nsmap). So you can use "wsdd:DiscoveryPRoxy" as a QName in Types because wsdd is a namespace prefix with a defined binding in the namespace table.</p>
<p>For UDP multicast, use</p>
<div class="fragment"><pre class="fragment">soap.connect_flags = SO_BROADCAST;
</pre></div><p>and optionally set the interface and TTL settings:</p>
<div class="fragment"><pre class="fragment">in_addr_t addr = inet_addr(<span class="stringliteral">&quot;1.2.3.4&quot;</span>);
soap.ipv4_multicast_if = &amp;addr; <span class="comment">// see setsockopt IPPROTO_IP IP_MULTICAST_IF</span>
soap.ipv6_multicast_if = addr; <span class="comment">// multicast sin6_scope_id</span>
soap.ipv4_multicast_ttl = 1; <span class="comment">// see setsockopt IPPROTO_IP, IP_MULTICAST_TTL</span>
</pre></div><p>Please refer to the socket options for IPPROTO_IP IP_MULTICAST_IF to specify the default interface for multicast datagrams to be sent from. Otherwise, the default interface set by the system administrator will be used (if any).</p>
<p>Please refer to the socket options for IPPROTO_IP IP_MULTICAST_TTL to limit the lifetime of the packet. Multicast datagrams are sent with a default value of 1, to prevent them to be forwarded beyond the local network. This parameter can be set between 1 to 255.</p>
<p>To send a Bye message by to leave a network:</p>
<div class="fragment"><pre class="fragment"><a class="code" href="wsddapi_8h.html#a5912eb51290b18adb51cfa80e8c55671" title="TS or DP Bye message to leave a network.">soap_wsdd_Bye</a>(soap,
  <a class="code" href="wsddapi_8h.html#a4d8f41b14eeb3500631fd39cad15b4a7a06282f02ad809feed167d23a3cf5ac46">SOAP_WSDD_MANAGED</a>,    <span class="comment">// or SOAP_WSDD_ADHOC for ad-hoc mode</span>
  <span class="stringliteral">&quot;to address&quot;</span>,         <span class="comment">// &quot;http(s):&quot; URL, or &quot;soap.udp:&quot; UDP, or TCP/IP address</span>
  <a class="code" href="wsaapi_8h.html#ac2b81c42093fc9fcadcf86e7d801e03b" title="Generates a random UUID (UUID algorithm version 4). Compile all source codes with -DWITH_OPENSSL for ...">soap_wsa_rand_uuid</a>(soap), <span class="comment">// a unique message ID</span>
  NULL,
  <span class="stringliteral">&quot;my address&quot;</span>,         <span class="comment">// where they can find me for WS-Discovery</span>
  <span class="stringliteral">&quot;wsdd:DiscoveryProxy&quot;</span>,<span class="comment">// Types: I&#39;m a DP</span>
  NULL,                 <span class="comment">// Scope</span>
  NULL,                 <span class="comment">// MatchBy</span>
  NULL,                 <span class="comment">// XAddrs</span>
  75965);               <span class="comment">// MDVersion</span>
</pre></div><p>To send a Probe message (see WS-Discovery 1.1 Section 1.7) and then listen to ProbeMatches:</p>
<div class="fragment"><pre class="fragment"><span class="keyword">struct </span>soap soap = soap_new(); <span class="comment">// to invoke messages</span>
<span class="keyword">struct </span>soap serv = soap_new(); <span class="comment">// for the listener and event handlers</span>

soap_bind(serv, port, 100);

<span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keywordtype">id</span> = <a class="code" href="wsaapi_8h.html#ac2b81c42093fc9fcadcf86e7d801e03b" title="Generates a random UUID (UUID algorithm version 4). Compile all source codes with -DWITH_OPENSSL for ...">soap_wsa_rand_uuid</a>(soap);
serv-&gt;user = (<span class="keywordtype">void</span>*)&amp;my_state;
my_state.probe_id = id;

<a class="code" href="wsddapi_8h.html#a79d93ab49aba655b6b767b28d0aff6ad" title="Client Probe message to a TS or DP.">soap_wsdd_Probe</a>(soap,
  <a class="code" href="wsddapi_8h.html#a4d8f41b14eeb3500631fd39cad15b4a7ac6264855642c10f4a15a1c2752ba7b91">SOAP_WSDD_ADHOC</a>,      <span class="comment">// ad-hoc mode</span>
  <a class="code" href="wsddapi_8h.html#adcd746964993574992fa2bafa83aed5caeaede3f37955eb85c93830a96b8d0b64">SOAP_WSDD_TO_TS</a>,      <span class="comment">// to a TS</span>
  <span class="stringliteral">&quot;to address&quot;</span>,         <span class="comment">// address of TS</span>
  <span class="keywordtype">id</span>,                   <span class="comment">// message ID</span>
  NULL,                 <span class="comment">// ReplyTo</span>
  <span class="stringliteral">&quot;\&quot;http://printer.example.org/2003/imaging\&quot;:PrintBasic&quot;</span>,
  <span class="stringliteral">&quot;ldap:///ou=engineering,o=examplecom,c=us&quot;</span>,
  <span class="stringliteral">&quot;http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01/ldap&quot;</span>);

<a class="code" href="wsddapi_8h.html#aeaf4e9c91f54ffcf09534b68b5ee6778" title="Listen on a port for inbound WS-Discovery messages.">soap_wsdd_listen</a>(serv, -1000);
</pre></div><p>The id is the WS-Addressing message ID that will be included in the ProbeMatches RelatesTo WS-Addressing header. As an example, my_state is set to this id so that when the <a class="el" href="wsddapi_8h.html#acbe8ef906112805937c9f19701649ba3">wsdd_event_ProbeMatches</a> event handler is invoked it can find the id in the current state that is pointed to by serv-&gt;user (soap-&gt;user in the handler).</p>
<p>To send a Resolve message and then listen to ResolveMatches:</p>
<div class="fragment"><pre class="fragment"><span class="keyword">struct </span>soap soap = soap_new(); <span class="comment">// to invoke messages</span>
<span class="keyword">struct </span>soap serv = soap_new(); <span class="comment">// for the listener and event handlers</span>

soap_bind(serv, port, 100);

<span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keywordtype">id</span> = <a class="code" href="wsaapi_8h.html#ac2b81c42093fc9fcadcf86e7d801e03b" title="Generates a random UUID (UUID algorithm version 4). Compile all source codes with -DWITH_OPENSSL for ...">soap_wsa_rand_uuid</a>(soap);
serv-&gt;user = (<span class="keywordtype">void</span>*)&amp;my_state;
my_state.resolve_id = id;

<a class="code" href="wsddapi_8h.html#acfcc0ff137be16fd9706f21faaeb7b23" title="Client Resolve message to a TS or DP.">soap_wsdd_Resolve</a>(soap,
  <a class="code" href="wsddapi_8h.html#a4d8f41b14eeb3500631fd39cad15b4a7ac6264855642c10f4a15a1c2752ba7b91">SOAP_WSDD_ADHOC</a>,      <span class="comment">// ad-hoc mode</span>
  <a class="code" href="wsddapi_8h.html#adcd746964993574992fa2bafa83aed5caeaede3f37955eb85c93830a96b8d0b64">SOAP_WSDD_TO_TS</a>,      <span class="comment">// to a TS</span>
  <span class="stringliteral">&quot;to address&quot;</span>,         <span class="comment">// address to send to</span>
  <span class="keywordtype">id</span>,                   <span class="comment">// message ID</span>
  NULL,                 <span class="comment">// ReplyTo</span>
  <span class="stringliteral">&quot;endpoint&quot;</span>);          <span class="comment">// EndpointReference of TS</span>
 
<a class="code" href="wsddapi_8h.html#aeaf4e9c91f54ffcf09534b68b5ee6778" title="Listen on a port for inbound WS-Discovery messages.">soap_wsdd_listen</a>(serv, -1000);
</pre></div><p>Again, the id and state are used to associate the asynchronously received ResolveMatches response that is handled by the <a class="el" href="wsddapi_8h.html#a6fe08bbe8ab19ff2a1e0874c0a104d18">wsdd_event_ResolveMatches</a> for the original request.</p>
<p>In managed mode with unicast messages (request-response messages), the <a class="el" href="wsddapi_8c.html#a79d93ab49aba655b6b767b28d0aff6ad">soap_wsdd_Probe</a> and <a class="el" href="wsddapi_8c.html#acfcc0ff137be16fd9706f21faaeb7b23">soap_wsdd_Resolve</a> are sufficient to invoke without setting up a listener. The event handlers are invoked when the unicast response message arrives.</p>
<p>In managed mode, the ProbeMatches and ResolveMatches are automatically sent via <a class="el" href="wsddapi_8c.html#aeaf4e9c91f54ffcf09534b68b5ee6778">soap_wsdd_listen</a> and the event <a class="el" href="wsddapi_8h.html#abbabd438789cc445ee72372722e7a6f4">wsdd_event_Probe</a> and <a class="el" href="wsddapi_8h.html#aeeb67571da9ca4a2da8730d49cae3021">wsdd_event_Resolve</a> handlers. These event handlers should set the matches to be returned.</p>
<p>In ad-hoc mode, ProbeMatches or ResolveMatches responses are NOT sent automatically. In ad-hoc mode the responses can be returned by adding code to the event handler or from anywhere in the main program, for example after <a class="el" href="wsddapi_8c.html#aeaf4e9c91f54ffcf09534b68b5ee6778">soap_wsdd_listen</a>. When responses are to be returned from the event handler or from the main program, you should invoke <a class="el" href="wsddapi_8c.html#ac1fd8fdfb24767d214f68659bfbe4187">soap_wsdd_ProbeMatches</a> and <a class="el" href="wsddapi_8c.html#a6a9722eaaef27e3655714b7592aa3af9">soap_wsdd_ResolveMatches</a> to explicitly send unicast messages with the match(es) back to the clients. The WS-Addressing ReplyTo address can be used as the return address (when not anonymous), or by using the peer's host information that is accessible in the soap-&gt;peer and soap-&gt;peerlen members. For example:</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">char</span> host[1024], port[16];
getnameinfo((<span class="keyword">struct</span> sockaddr*)&amp;soap-&gt;peer, soap-&gt;peerlen, host, <span class="keyword">sizeof</span>(host), port, 16, NI_DGRAM | NI_NAMEREQD | NI_NUMERICSERV);
</pre></div><h2><a class="anchor" id="wsdd_5"></a>
Generating C++ Server Objects</h2>
<p>The WSDD library is developed to support C and C++. To support C++ server objects generated with soapcpp2 options -i and -j, you need to define in your C++ code the following wrappers (use this-&gt;soap below for soapcpp2 option -j):</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> wsddService::Hello(<span class="keyword">struct</span> <a class="code" href="structwsdd_____hello_type.html" title="&quot;http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01&quot;:HelloType is a complexType.">wsdd__HelloType</a> *hello)
{ <span class="keywordflow">return</span> <a class="code" href="wsddapi_8h.html#a5ff39c1ead345380963b292a21dc9960" title="Internal WS-Discovery service operation.">__wsdd__Hello</a>(<span class="keyword">this</span>, hello);
}
<span class="keywordtype">int</span> wsddService::Bye(<span class="keyword">struct</span> <a class="code" href="structwsdd_____bye_type.html" title="&quot;http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01&quot;:ByeType is a complexType.">wsdd__ByeType</a> *bye
{ <span class="keywordflow">return</span> <a class="code" href="wsddapi_8h.html#a2ade69029974cbac3b06afb74d452964" title="Internal WS-Discovery service operation.">__wsdd__Bye</a>(<span class="keyword">this</span>, bye);
}
<span class="keywordtype">int</span> wsddService::Probe(<span class="keyword">struct</span> <a class="code" href="structwsdd_____probe_type.html" title="&quot;http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01&quot;:ProbeType is a complexType.">wsdd__ProbeType</a> *probe)
{ <span class="keywordflow">return</span> <a class="code" href="wsddapi_8h.html#a29c3eb211a71c1fab6c773f5b5ed1adb" title="Internal WS-Discovery service operation.">__wsdd__Probe</a>(<span class="keyword">this</span>, probe);
}
<span class="keywordtype">int</span> wsddService::ProbeMatches(<span class="keyword">struct</span> <a class="code" href="structwsdd_____probe_matches_type.html" title="&quot;http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01&quot;:ProbeMatchesType is a complexType.">wsdd__ProbeMatchesType</a> *matches)
{ <span class="keywordflow">return</span> <a class="code" href="wsddapi_8h.html#aaaabc1f3cc187e5724470cbfdeed1da6" title="Internal WS-Discovery service operation.">__wsdd__ProbeMatches</a>(<span class="keyword">this</span>, matches);
}
<span class="keywordtype">int</span> wsddService::Resolve(<span class="keyword">struct</span> <a class="code" href="structwsdd_____resolve_type.html" title="&quot;http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01&quot;:ResolveType is a complexType.">wsdd__ResolveType</a> *resolve)
{ <span class="keywordflow">return</span> <a class="code" href="wsddapi_8h.html#aa0ace89168d2e0180730cf42e0c96127" title="Internal WS-Discovery service operation.">__wsdd__Resolve</a>(<span class="keyword">this</span>, resolve);
}
<span class="keywordtype">int</span> wsddService::ResolveProbeMatches(<span class="keyword">struct</span> <a class="code" href="structwsdd_____resolve_matches_type.html" title="&quot;http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01&quot;:ResolveMatchesType is a complexType.">wsdd__ResolveMatchesType</a> *matches)
{ <span class="keywordflow">return</span> <a class="code" href="wsddapi_8h.html#af1a35f73401918b02c3aa704cbb606ff" title="Internal WS-Discovery service operation.">__wsdd__ResolveMatches</a>(<span class="keyword">this</span>, matches);
}
</pre></div><p>Another approach to generate the WSDD service operations is to run soapcpp2 separately on <a class="el" href="wsdd_8h.html">wsdd.h</a> (or wsdd10.h for WS-Discovery 1.0) by soapcpp2 -a -L -pwsdd <a class="el" href="wsdd_8h.html">wsdd.h</a> to generate wsddService.cpp. Then chain the service operations at the server side:</p>
<div class="fragment"><pre class="fragment"><span class="keywordflow">if</span> (soap_begin_serve(service.soap) == SOAP_OK)
  <span class="keywordflow">if</span> (service.dispatch() == SOAP_NO_METHOD)
    soap_serve_request(service.soap);
</pre></div><p>where the 'service' object is an instance of the application services generated by soapcpp2 -j.</p>
<h2><a class="anchor" id="wsdd_6"></a>
Miscellaneous</h2>
<p>You MUST generate client-side operations that the WSDD library expects to be linked with, by executing:</p>
<div class="fragment"><pre class="fragment">&gt; soapcpp2 -L -pwsdd -Iimport <span class="keyword">import</span>/wsdd.h
</pre></div><p>Then compile and link the generated wsddClient.cpp code with your project.</p>
<p>Because WS-Addressing may relay faults to a FaultTo service, you need to define a SOAP Fault service operation to accept and handle these:</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> <a class="code" href="wsa5_8h.html#af1f0af3d70354401b6969aa0b689a5dc">SOAP_ENV__Fault</a>(<span class="keyword">struct</span> soap *soap, <span class="keywordtype">char</span> *faultcode, <span class="keywordtype">char</span> *faultstring, <span class="keywordtype">char</span> *faultactor, <span class="keyword">struct</span> SOAP_ENV__Detail *detail, <span class="keyword">struct</span> SOAP_ENV__Code *SOAP_ENV__Code, <span class="keyword">struct</span> SOAP_ENV__Reason *SOAP_ENV__Reason, <span class="keywordtype">char</span> *SOAP_ENV__Node, <span class="keywordtype">char</span> *SOAP_ENV__Role, <span class="keyword">struct</span> SOAP_ENV__Detail *SOAP_ENV__Detail)
{ 
  ... = faultcode; <span class="comment">// SOAP 1.1 fault code string (QName)</span>
  ... = faultstring; <span class="comment">// SOAP 1.1 fault string</span>
  ... = faultactor; <span class="comment">// SOAP 1.1 fault actor string</span>
  ... = detail; <span class="comment">// SOAP 1.1 fault detail struct</span>
  ... = SOAP_ENV__Code; <span class="comment">// SOAP 1.2 fault code struct</span>
  ... = SOAP_ENV__Reason; <span class="comment">// SOAP 1.2 reason struct</span>
  ... = SOAP_ENV__Node; <span class="comment">// SOAP 1.2 node string</span>
  ... = SOAP_ENV__Role; <span class="comment">// SOAP 1.2 role string</span>
  ... = SOAP_ENV__Detail; <span class="comment">// SOAP 1.2 detail struct</span>
  <span class="keywordflow">return</span> SOAP_OK;
}
</pre></div> </div></div>
<hr class="footer"/><address class="footer"><small>Generated on Sun Dec 9 2012 19:57:57 for gSOAP WS-Discovery by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
