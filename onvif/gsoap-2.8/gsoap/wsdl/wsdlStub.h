/* wsdlStub.h
   Generated by gSOAP 2.8.17r from ./wsdl.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#ifndef wsdlStub_H
#define wsdlStub_H
#include <vector>
#include "includes.h"
#include "stdsoap2.h"
#if GSOAP_VERSION != 20817
# error "GSOAP VERSION MISMATCH IN GENERATED CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


#ifndef SOAP_TYPE_xs__formChoice
#define SOAP_TYPE_xs__formChoice (31)
/* xs:formChoice */
enum xs__formChoice { unqualified = 0, qualified = 1 };
#endif

#ifndef SOAP_TYPE_xs__attribute_use
#define SOAP_TYPE_xs__attribute_use (59)
/* xs:attribute-use */
enum xs__attribute_use { optional = 0, prohibited = 1, required = 2, default_ = 3, fixed_ = 4 };
#endif

#ifndef SOAP_TYPE_xs__processContents
#define SOAP_TYPE_xs__processContents (74)
/* xs:processContents */
enum xs__processContents { strict = 0, skip = 1, lax = 2 };
#endif

#ifndef SOAP_TYPE_soap__styleChoice
#define SOAP_TYPE_soap__styleChoice (217)
/* soap:styleChoice */
enum soap__styleChoice { rpc = 0, document = 1 };
#endif

#ifndef SOAP_TYPE_soap__useChoice
#define SOAP_TYPE_soap__useChoice (221)
/* soap:useChoice */
enum soap__useChoice { literal = 0, encoded = 1 };
#endif

#ifndef SOAP_TYPE_sd__mutability
#define SOAP_TYPE_sd__mutability (264)
/* sd:mutability */
enum sd__mutability { static_ = 0, constant = 1, extendable = 2, mutable_ = 3 };
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif







#ifndef SOAP_TYPE_xs__annotation
#define SOAP_TYPE_xs__annotation (30)
/* xs:annotation */
class SOAP_CMAC xs__annotation
{
public:
	char *documentation;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 30; } /* = unique type id SOAP_TYPE_xs__annotation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xs__annotation() { xs__annotation::soap_default(NULL); }
	virtual ~xs__annotation() { }
};
#endif

#ifndef SOAP_TYPE_xs__element
#define SOAP_TYPE_xs__element (32)
/* xs:element */
class SOAP_CMAC xs__element
{
public:
	char *name;	/* optional attribute */
	char *ref;	/* optional attribute */
	char *type;	/* optional attribute */
	char *default_;	/* optional attribute */
	char *default__;	/* optional attribute */
	char *fixed;	/* optional attribute */
	char *fixed_;	/* optional attribute */
	enum xs__formChoice *form;	/* optional attribute */
	bool nillable;	/* optional attribute */
	bool abstract;	/* optional attribute */
	char *substitutionGroup;	/* optional attribute */
	char *minOccurs;	/* optional attribute */
	char *maxOccurs;	/* optional attribute */
	char *xmime__expectedContentTypes;	/* optional attribute */
	xs__annotation *annotation;	/* optional element of type xs:annotation */
	class xs__simpleType *simpleType;	/* optional element of type xs:simpleType */
	class xs__complexType *complexType;	/* optional element of type xs:complexType */
	char *unique;	/* optional element of type xsd:string */
private:
	class xs__schema *schemaRef;	/* not serialized */
	xs__element *elementRef;	/* not serialized */
	xs__simpleType *simpleTypeRef;	/* not serialized */
	xs__complexType *complexTypeRef;	/* not serialized */
	std::vector<xs__element * >substitutions;	/* not serialized */
public:
	xs__element();	/* transient */
	int traverse(xs__schema &_param_1);	/* transient */
	void schemaPtr(xs__schema *_param_2);	/* transient */
	void elementPtr(xs__element *_param_3);	/* transient */
	void simpleTypePtr(xs__simpleType *_param_4);	/* transient */
	void complexTypePtr(xs__complexType *_param_5);	/* transient */
	xs__schema *schemaPtr() const;	/* transient */
	xs__element *elementPtr() const;	/* transient */
	xs__simpleType *simpleTypePtr() const;	/* transient */
	xs__complexType *complexTypePtr() const;	/* transient */
	const std::vector<xs__element * >*substitutionsPtr() const;	/* transient */
public:
	virtual int soap_type() const { return 32; } /* = unique type id SOAP_TYPE_xs__element */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~xs__element() { }
};
#endif

#ifndef SOAP_TYPE_xs__attribute
#define SOAP_TYPE_xs__attribute (60)
/* xs:attribute */
class SOAP_CMAC xs__attribute
{
public:
	char *name;	/* optional attribute */
	char *ref;	/* optional attribute */
	char *type;	/* optional attribute */
	enum xs__attribute_use use;	/* optional attribute */
	char *default_;	/* optional attribute */
	char *default__;	/* optional attribute */
	char *fixed;	/* optional attribute */
	char *fixed_;	/* optional attribute */
	enum xs__formChoice *form;	/* optional attribute */
	char *wsdl__arrayType;	/* optional attribute */
	xs__annotation *annotation;	/* optional element of type xs:annotation */
	xs__simpleType *simpleType;	/* optional element of type xs:simpleType */
private:
	xs__schema *schemaRef;	/* not serialized */
	xs__attribute *attributeRef;	/* not serialized */
	xs__simpleType *simpleTypeRef;	/* not serialized */
public:
	xs__attribute();	/* transient */
	int traverse(xs__schema &_param_6);	/* transient */
	void schemaPtr(xs__schema *_param_7);	/* transient */
	void attributePtr(xs__attribute *_param_8);	/* transient */
	void simpleTypePtr(xs__simpleType *_param_9);	/* transient */
	xs__schema *schemaPtr() const;	/* transient */
	xs__attribute *attributePtr() const;	/* transient */
	xs__simpleType *simpleTypePtr() const;	/* transient */
public:
	virtual int soap_type() const { return 60; } /* = unique type id SOAP_TYPE_xs__attribute */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~xs__attribute() { }
};
#endif

#ifndef SOAP_TYPE_xs__all
#define SOAP_TYPE_xs__all (71)
/* xs:all */
class SOAP_CMAC xs__all
{
public:
	std::vector<xs__element >element;	/* optional element of type xs:element */
	int traverse(xs__schema &_param_10);	/* transient */
public:
	virtual int soap_type() const { return 71; } /* = unique type id SOAP_TYPE_xs__all */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xs__all() { xs__all::soap_default(NULL); }
	virtual ~xs__all() { }
};
#endif

#ifndef SOAP_TYPE_xs__any
#define SOAP_TYPE_xs__any (76)
/* xs:any */
class SOAP_CMAC xs__any
{
public:
	char *namespace_;	/* optional attribute */
	enum xs__processContents processContents;	/* optional attribute */
	char *minOccurs;	/* optional attribute */
	char *maxOccurs;	/* optional attribute */
	std::vector<xs__element >element;	/* optional element of type xs:element */
	int traverse(xs__schema &_param_11);	/* transient */
public:
	virtual int soap_type() const { return 76; } /* = unique type id SOAP_TYPE_xs__any */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xs__any() { xs__any::soap_default(NULL); }
	virtual ~xs__any() { }
};
#endif

#ifndef SOAP_TYPE_xs__union_content
#define SOAP_TYPE_xs__union_content (82)
/* xsd:choice */
union xs__union_content
{
#define SOAP_UNION_xs__union_content_element	(1)
	xs__element *element;
#define SOAP_UNION_xs__union_content_group	(2)
	class xs__group *group;
#define SOAP_UNION_xs__union_content_choice	(3)
	class xs__seqchoice *choice;
#define SOAP_UNION_xs__union_content_sequence	(4)
	xs__seqchoice *sequence;
#define SOAP_UNION_xs__union_content_any	(5)
	xs__any *any;
};
#endif

#ifndef SOAP_TYPE_xs__contents
#define SOAP_TYPE_xs__contents (78)
/* Choice: */
class SOAP_CMAC xs__contents
{
public:
	int __union;	/* union discriminant (of union defined below) */
	union xs__union_content __content;
	int traverse(xs__schema &_param_12);	/* transient */
public:
	virtual int soap_type() const { return 78; } /* = unique type id SOAP_TYPE_xs__contents */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xs__contents() { xs__contents::soap_default(NULL); }
	virtual ~xs__contents() { }
};
#endif

#ifndef SOAP_TYPE_xs__seqchoice
#define SOAP_TYPE_xs__seqchoice (26)
/* xs:seqchoice */
class SOAP_CMAC xs__seqchoice
{
public:
	char *minOccurs;	/* optional attribute */
	char *maxOccurs;	/* optional attribute */
	xs__annotation *annotation;	/* optional element of type xs:annotation */
	std::vector<xs__contents >__contents;
private:
	xs__schema *schemaRef;	/* not serialized */
public:
	xs__seqchoice();	/* transient */
	int traverse(xs__schema &_param_13);	/* transient */
	void schemaPtr(xs__schema *_param_14);	/* transient */
	xs__schema *schemaPtr() const;	/* transient */
public:
	virtual int soap_type() const { return 26; } /* = unique type id SOAP_TYPE_xs__seqchoice */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~xs__seqchoice() { }
};
#endif

#ifndef SOAP_TYPE_xs__group
#define SOAP_TYPE_xs__group (27)
/* xs:group */
class SOAP_CMAC xs__group
{
public:
	char *name;	/* optional attribute */
	char *ref;	/* optional attribute */
	char *minOccurs;	/* optional attribute */
	char *maxOccurs;	/* optional attribute */
	xs__annotation *annotation;	/* optional element of type xs:annotation */
	xs__all *all;	/* optional element of type xs:all */
	xs__seqchoice *choice;	/* optional element of type xs:seqchoice */
	xs__seqchoice *sequence;	/* optional element of type xs:seqchoice */
private:
	xs__schema *schemaRef;	/* not serialized */
	xs__group *groupRef;	/* not serialized */
public:
	xs__group();	/* transient */
	int traverse(xs__schema &_param_15);	/* transient */
	void schemaPtr(xs__schema *_param_16);	/* transient */
	void groupPtr(xs__group *_param_17);	/* transient */
	xs__schema *schemaPtr() const;	/* transient */
	xs__group *groupPtr() const;	/* transient */
public:
	virtual int soap_type() const { return 27; } /* = unique type id SOAP_TYPE_xs__group */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~xs__group() { }
};
#endif

#ifndef SOAP_TYPE_xs__anyAttribute
#define SOAP_TYPE_xs__anyAttribute (97)
/* xs:anyAttribute */
class SOAP_CMAC xs__anyAttribute
{
public:
	char *namespace_;	/* optional attribute */
	enum xs__processContents processContents;	/* optional attribute */
public:
	virtual int soap_type() const { return 97; } /* = unique type id SOAP_TYPE_xs__anyAttribute */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xs__anyAttribute() { xs__anyAttribute::soap_default(NULL); }
	virtual ~xs__anyAttribute() { }
};
#endif

#ifndef SOAP_TYPE_xs__attributeGroup
#define SOAP_TYPE_xs__attributeGroup (98)
/* xs:attributeGroup */
class SOAP_CMAC xs__attributeGroup
{
public:
	char *name;	/* optional attribute */
	char *ref;	/* optional attribute */
	xs__annotation *annotation;	/* optional element of type xs:annotation */
	std::vector<xs__attribute >attribute;	/* optional element of type xs:attribute */
	std::vector<xs__attributeGroup >attributeGroup;	/* optional element of type xs:attributeGroup */
	xs__anyAttribute *anyAttribute;	/* optional element of type xs:anyAttribute */
private:
	xs__schema *schemaRef;	/* not serialized */
	xs__attributeGroup *attributeGroupRef;	/* not serialized */
public:
	xs__attributeGroup();	/* transient */
	int traverse(xs__schema &_param_18);	/* transient */
	void schemaPtr(xs__schema *_param_19);	/* transient */
	void attributeGroupPtr(xs__attributeGroup *_param_20);	/* transient */
	xs__schema *schemaPtr() const;	/* transient */
	xs__attributeGroup *attributeGroupPtr() const;	/* transient */
public:
	virtual int soap_type() const { return 98; } /* = unique type id SOAP_TYPE_xs__attributeGroup */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~xs__attributeGroup() { }
};
#endif

#ifndef SOAP_TYPE_xs__enumeration
#define SOAP_TYPE_xs__enumeration (110)
/* xs:enumeration */
class SOAP_CMAC xs__enumeration
{
public:
	char *value;	/* optional attribute */
	char *value_;	/* optional attribute */
	xs__annotation *annotation;	/* optional element of type xs:annotation */
	int traverse(xs__schema &_param_21);	/* transient */
public:
	virtual int soap_type() const { return 110; } /* = unique type id SOAP_TYPE_xs__enumeration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xs__enumeration() { xs__enumeration::soap_default(NULL); }
	virtual ~xs__enumeration() { }
};
#endif

#ifndef SOAP_TYPE_xs__pattern
#define SOAP_TYPE_xs__pattern (112)
/* xs:pattern */
class SOAP_CMAC xs__pattern
{
public:
	char *value;	/* optional attribute */
	int traverse(xs__schema &_param_22);	/* transient */
public:
	virtual int soap_type() const { return 112; } /* = unique type id SOAP_TYPE_xs__pattern */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xs__pattern() { xs__pattern::soap_default(NULL); }
	virtual ~xs__pattern() { }
};
#endif

#ifndef SOAP_TYPE_xs__simpleContent
#define SOAP_TYPE_xs__simpleContent (114)
/* xs:simpleContent */
class SOAP_CMAC xs__simpleContent
{
public:
	class xs__extension *extension;	/* optional element of type xs:extension */
	class xs__restriction *restriction;	/* optional element of type xs:restriction */
	int traverse(xs__schema &_param_23);	/* transient */
public:
	virtual int soap_type() const { return 114; } /* = unique type id SOAP_TYPE_xs__simpleContent */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xs__simpleContent() { xs__simpleContent::soap_default(NULL); }
	virtual ~xs__simpleContent() { }
};
#endif

#ifndef SOAP_TYPE_xs__simpleType
#define SOAP_TYPE_xs__simpleType (22)
/* xs:simpleType */
class SOAP_CMAC xs__simpleType
{
public:
	char *name;	/* optional attribute */
	xs__annotation *annotation;	/* optional element of type xs:annotation */
	xs__restriction *restriction;	/* optional element of type xs:restriction */
	class xs__list *list;	/* optional element of type xs:list */
	class xs__union *union_;	/* optional element of type xs:union */
private:
	xs__schema *schemaRef;	/* not serialized */
	int level;	/* not serialized */
public:
	xs__simpleType();	/* transient */
	int traverse(xs__schema &_param_24);	/* transient */
	void schemaPtr(xs__schema *_param_25);	/* transient */
	xs__schema *schemaPtr() const;	/* transient */
	int baseLevel();	/* transient */
public:
	virtual int soap_type() const { return 22; } /* = unique type id SOAP_TYPE_xs__simpleType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~xs__simpleType() { }
};
#endif

#ifndef SOAP_TYPE_xs__extension
#define SOAP_TYPE_xs__extension (24)
/* xs:extension */
class SOAP_CMAC xs__extension
{
public:
	char *base;	/* optional attribute */
	xs__group *group;	/* optional element of type xs:group */
	xs__all *all;	/* optional element of type xs:all */
	xs__seqchoice *choice;	/* optional element of type xs:seqchoice */
	xs__seqchoice *sequence;	/* optional element of type xs:seqchoice */
	std::vector<xs__attribute >attribute;	/* optional element of type xs:attribute */
	std::vector<xs__attributeGroup >attributeGroup;	/* optional element of type xs:attributeGroup */
	xs__anyAttribute *anyAttribute;	/* optional element of type xs:anyAttribute */
private:
	xs__simpleType *simpleTypeRef;	/* not serialized */
	xs__complexType *complexTypeRef;	/* not serialized */
public:
	xs__extension();	/* transient */
	int traverse(xs__schema &_param_26);	/* transient */
	void simpleTypePtr(xs__simpleType *_param_27);	/* transient */
	void complexTypePtr(xs__complexType *_param_28);	/* transient */
	xs__simpleType *simpleTypePtr() const;	/* transient */
	xs__complexType *complexTypePtr() const;	/* transient */
public:
	virtual int soap_type() const { return 24; } /* = unique type id SOAP_TYPE_xs__extension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~xs__extension() { }
};
#endif

#ifndef SOAP_TYPE_xs__length
#define SOAP_TYPE_xs__length (131)
/* xs:length */
class SOAP_CMAC xs__length
{
public:
	char *value;	/* optional attribute */
	bool fixed;	/* optional attribute */
	xs__annotation *annotation;	/* optional element of type xs:annotation */
public:
	virtual int soap_type() const { return 131; } /* = unique type id SOAP_TYPE_xs__length */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xs__length() { xs__length::soap_default(NULL); }
	virtual ~xs__length() { }
};
#endif

#ifndef SOAP_TYPE_xs__whiteSpace
#define SOAP_TYPE_xs__whiteSpace (132)
/* xs:whiteSpace */
class SOAP_CMAC xs__whiteSpace
{
public:
	char *value;	/* optional attribute */
public:
	virtual int soap_type() const { return 132; } /* = unique type id SOAP_TYPE_xs__whiteSpace */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xs__whiteSpace() { xs__whiteSpace::soap_default(NULL); }
	virtual ~xs__whiteSpace() { }
};
#endif

#ifndef SOAP_TYPE_xs__restriction
#define SOAP_TYPE_xs__restriction (25)
/* xs:restriction */
class SOAP_CMAC xs__restriction
{
public:
	char *base;	/* optional attribute */
	xs__simpleType *simpleType;	/* optional element of type xs:simpleType */
	xs__attributeGroup *attributeGroup;	/* optional element of type xs:attributeGroup */
	xs__group *group;	/* optional element of type xs:group */
	xs__all *all;	/* optional element of type xs:all */
	xs__seqchoice *choice;	/* optional element of type xs:seqchoice */
	xs__seqchoice *sequence;	/* optional element of type xs:seqchoice */
	std::vector<xs__attribute >attribute;	/* optional element of type xs:attribute */
	xs__anyAttribute *anyAttribute;	/* optional element of type xs:anyAttribute */
	std::vector<xs__enumeration >enumeration;	/* optional element of type xs:enumeration */
	std::vector<xs__pattern >pattern;	/* optional element of type xs:pattern */
	xs__whiteSpace *whiteSpace;	/* optional element of type xs:whiteSpace */
	xs__length *length;	/* optional element of type xs:length */
	xs__length *minLength;	/* optional element of type xs:length */
	xs__length *maxLength;	/* optional element of type xs:length */
	xs__length *precision;	/* optional element of type xs:length */
	xs__length *scale;	/* optional element of type xs:length */
	xs__length *totalDigits;	/* optional element of type xs:length */
	xs__length *fractionDigits;	/* optional element of type xs:length */
	xs__length *minInclusive;	/* optional element of type xs:length */
	xs__length *maxInclusive;	/* optional element of type xs:length */
	xs__length *minExclusive;	/* optional element of type xs:length */
	xs__length *maxExclusive;	/* optional element of type xs:length */
	xs__annotation *annotation;	/* optional element of type xs:annotation */
private:
	xs__simpleType *simpleTypeRef;	/* not serialized */
	xs__complexType *complexTypeRef;	/* not serialized */
public:
	xs__restriction();	/* transient */
	int traverse(xs__schema &_param_29);	/* transient */
	void simpleTypePtr(xs__simpleType *_param_30);	/* transient */
	void complexTypePtr(xs__complexType *_param_31);	/* transient */
	xs__simpleType *simpleTypePtr() const;	/* transient */
	xs__complexType *complexTypePtr() const;	/* transient */
public:
	virtual int soap_type() const { return 25; } /* = unique type id SOAP_TYPE_xs__restriction */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~xs__restriction() { }
};
#endif

#ifndef SOAP_TYPE_xs__list
#define SOAP_TYPE_xs__list (28)
/* xs:list */
class SOAP_CMAC xs__list
{
public:
	char *itemType;	/* optional attribute */
	xs__restriction *restriction;	/* optional element of type xs:restriction */
	std::vector<xs__simpleType >simpleType;	/* optional element of type xs:simpleType */
private:
	xs__simpleType *itemTypeRef;	/* not serialized */
public:
	xs__list();	/* transient */
	int traverse(xs__schema &_param_32);	/* transient */
	void itemTypePtr(xs__simpleType *_param_33);	/* transient */
	xs__simpleType *itemTypePtr() const;	/* transient */
public:
	virtual int soap_type() const { return 28; } /* = unique type id SOAP_TYPE_xs__list */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~xs__list() { }
};
#endif

#ifndef SOAP_TYPE_xs__union
#define SOAP_TYPE_xs__union (29)
/* xs:union */
class SOAP_CMAC xs__union
{
public:
	char *memberTypes;	/* optional attribute */
	std::vector<xs__simpleType >simpleType;	/* optional element of type xs:simpleType */
	int traverse(xs__schema &_param_34);	/* transient */
public:
	virtual int soap_type() const { return 29; } /* = unique type id SOAP_TYPE_xs__union */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xs__union() { xs__union::soap_default(NULL); }
	virtual ~xs__union() { }
};
#endif

#ifndef SOAP_TYPE_xs__complexContent
#define SOAP_TYPE_xs__complexContent (149)
/* xs:complexContent */
class SOAP_CMAC xs__complexContent
{
public:
	bool mixed;	/* optional attribute */
	xs__extension *extension;	/* optional element of type xs:extension */
	xs__restriction *restriction;	/* optional element of type xs:restriction */
	int traverse(xs__schema &_param_35);	/* transient */
public:
	virtual int soap_type() const { return 149; } /* = unique type id SOAP_TYPE_xs__complexContent */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xs__complexContent() { xs__complexContent::soap_default(NULL); }
	virtual ~xs__complexContent() { }
};
#endif

#ifndef SOAP_TYPE_xs__complexType
#define SOAP_TYPE_xs__complexType (23)
/* xs:complexType */
class SOAP_CMAC xs__complexType
{
public:
	char *name;	/* optional attribute */
	bool abstract;	/* optional attribute */
	bool mixed;	/* optional attribute */
	xs__annotation *annotation;	/* optional element of type xs:annotation */
	xs__simpleContent *simpleContent;	/* optional element of type xs:simpleContent */
	xs__complexContent *complexContent;	/* optional element of type xs:complexContent */
	xs__all *all;	/* optional element of type xs:all */
	xs__seqchoice *choice;	/* optional element of type xs:seqchoice */
	xs__seqchoice *sequence;	/* optional element of type xs:seqchoice */
	xs__any *any;	/* optional element of type xs:any */
	std::vector<xs__attribute >attribute;	/* optional element of type xs:attribute */
	std::vector<xs__attributeGroup >attributeGroup;	/* optional element of type xs:attributeGroup */
	xs__anyAttribute *anyAttribute;	/* optional element of type xs:anyAttribute */
private:
	xs__schema *schemaRef;	/* not serialized */
	int level;	/* not serialized */
public:
	xs__complexType();	/* transient */
	int traverse(xs__schema &_param_36);	/* transient */
	void schemaPtr(xs__schema *_param_37);	/* transient */
	xs__schema *schemaPtr() const;	/* transient */
	int baseLevel();	/* transient */
public:
	virtual int soap_type() const { return 23; } /* = unique type id SOAP_TYPE_xs__complexType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~xs__complexType() { }
};
#endif

#ifndef SOAP_TYPE_xs__import
#define SOAP_TYPE_xs__import (158)
/* xs:import */
class SOAP_CMAC xs__import
{
public:
	char *namespace_;	/* optional attribute */
	char *schemaLocation;	/* optional attribute */
private:
	xs__schema *schemaRef;	/* not serialized */
public:
	xs__import();	/* transient */
	int traverse(xs__schema &_param_38);	/* transient */
	void schemaPtr(xs__schema *_param_39);	/* transient */
	xs__schema *schemaPtr() const;	/* transient */
public:
	virtual int soap_type() const { return 158; } /* = unique type id SOAP_TYPE_xs__import */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~xs__import() { }
};
#endif

#ifndef SOAP_TYPE_xs__include
#define SOAP_TYPE_xs__include (163)
/* xs:include */
class SOAP_CMAC xs__include
{
public:
	char *schemaLocation;	/* optional attribute */
private:
	xs__schema *schemaRef;	/* not serialized */
public:
	xs__include();	/* transient */
	int preprocess(xs__schema &_param_40);	/* transient */
	int traverse(xs__schema &_param_41);	/* transient */
	void schemaPtr(xs__schema *_param_42);	/* transient */
	xs__schema *schemaPtr() const;	/* transient */
public:
	virtual int soap_type() const { return 163; } /* = unique type id SOAP_TYPE_xs__include */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~xs__include() { }
};
#endif

#ifndef SOAP_TYPE_xs__redefine
#define SOAP_TYPE_xs__redefine (169)
/* xs:redefine */
class SOAP_CMAC xs__redefine
{
public:
	char *schemaLocation;	/* optional attribute */
	std::vector<xs__group >group;	/* optional element of type xs:group */
	std::vector<xs__attributeGroup >attributeGroup;	/* optional element of type xs:attributeGroup */
	std::vector<xs__simpleType >simpleType;	/* optional element of type xs:simpleType */
	std::vector<xs__complexType >complexType;	/* optional element of type xs:complexType */
private:
	xs__schema *schemaRef;	/* not serialized */
public:
	xs__redefine();	/* transient */
	int preprocess(xs__schema &_param_43);	/* transient */
	int traverse(xs__schema &_param_44);	/* transient */
	void schemaPtr(xs__schema *_param_45);	/* transient */
	xs__schema *schemaPtr() const;	/* transient */
public:
	virtual int soap_type() const { return 169; } /* = unique type id SOAP_TYPE_xs__redefine */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~xs__redefine() { }
};
#endif

#ifndef SOAP_TYPE_xs__schema
#define SOAP_TYPE_xs__schema (21)
/* xs:schema */
class SOAP_CMAC xs__schema
{
public:
	char *targetNamespace;	/* optional attribute */
	char *version;	/* optional attribute */
	enum xs__formChoice attributeFormDefault;	/* optional attribute */
	enum xs__formChoice elementFormDefault;	/* optional attribute */
	xs__annotation *annotation;	/* optional element of type xs:annotation */
	std::vector<xs__include >include;	/* optional element of type xs:include */
	std::vector<xs__redefine >redefine;	/* optional element of type xs:redefine */
	std::vector<xs__import >import;	/* optional element of type xs:import */
	std::vector<xs__attribute >attribute;	/* optional element of type xs:attribute */
	std::vector<xs__element >element;	/* optional element of type xs:element */
	std::vector<xs__group >group;	/* optional element of type xs:group */
	std::vector<xs__attributeGroup >attributeGroup;	/* optional element of type xs:attributeGroup */
	std::vector<xs__simpleType >simpleType;	/* optional element of type xs:simpleType */
	std::vector<xs__complexType >complexType;	/* optional element of type xs:complexType */
	struct soap *soap;	/* transient */
private:
	bool updated;	/* not serialized */
	char *location;	/* not serialized */
	int redirs;	/* not serialized */
	SetOfString builtinTypeSet;	/* transient */	/* not serialized */
	SetOfString builtinElementSet;	/* transient */	/* not serialized */
	SetOfString builtinAttributeSet;	/* transient */	/* not serialized */
public:
	xs__schema();	/* transient */
	xs__schema(struct soap *_param_46);	/* transient */
	xs__schema(struct soap *_param_47, const char *_param_48, const char *_param_49);	/* transient */
	virtual ~xs__schema();	/* transient */
	int get(struct soap *_param_50);	/* transient */
	int preprocess();	/* transient */
	int insert(xs__schema &_param_51);	/* transient */
	int traverse();	/* transient */
	int read(const char *_param_52, const char *_param_53);	/* transient */
	void sourceLocation(const char *_param_54);	/* transient */
	const char *sourceLocation();	/* transient */
	int error();	/* transient */
	void print_fault();	/* transient */
	void builtinType(const char *_param_55);	/* transient */
	void builtinElement(const char *_param_56);	/* transient */
	void builtinAttribute(const char *_param_57);	/* transient */
	const SetOfString &builtinTypes() const;	/* transient */	/* not serialized */
	const SetOfString &builtinElements() const;	/* transient */	/* not serialized */
	const SetOfString &builtinAttributes() const;	/* transient */	/* not serialized */
	bool empty() const;	/* transient */
	friend ostream &operator<<(ostream &_param_58, const xs__schema &_param_59);	/* transient */
	friend istream &operator>>(istream &_param_60, xs__schema &_param_61);	/* transient */
public:
	virtual int soap_type() const { return 21; } /* = unique type id SOAP_TYPE_xs__schema */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
};
#endif

#ifndef SOAP_TYPE_soap__binding
#define SOAP_TYPE_soap__binding (218)
/* soap:binding */
class SOAP_CMAC soap__binding
{
public:
	char *transport;	/* optional attribute */
	enum soap__styleChoice *style;	/* optional attribute */
public:
	virtual int soap_type() const { return 218; } /* = unique type id SOAP_TYPE_soap__binding */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         soap__binding() { soap__binding::soap_default(NULL); }
	virtual ~soap__binding() { }
};
#endif

#ifndef SOAP_TYPE_soap__operation
#define SOAP_TYPE_soap__operation (220)
/* soap:operation */
class SOAP_CMAC soap__operation
{
public:
	char *soapAction;	/* optional attribute */
	bool soapActionRequired;	/* optional attribute */
	enum soap__styleChoice *style;	/* optional attribute */
public:
	virtual int soap_type() const { return 220; } /* = unique type id SOAP_TYPE_soap__operation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         soap__operation() { soap__operation::soap_default(NULL); }
	virtual ~soap__operation() { }
};
#endif

#ifndef SOAP_TYPE_soap__body
#define SOAP_TYPE_soap__body (222)
/* soap:body */
class SOAP_CMAC soap__body
{
public:
	char *encodingStyle;	/* optional attribute */
	char *parts;	/* optional attribute */
	enum soap__useChoice use;	/* optional attribute */
	char *namespace_;	/* optional attribute */
public:
	virtual int soap_type() const { return 222; } /* = unique type id SOAP_TYPE_soap__body */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         soap__body() { soap__body::soap_default(NULL); }
	virtual ~soap__body() { }
};
#endif

#ifndef SOAP_TYPE_soap__fault
#define SOAP_TYPE_soap__fault (223)
/* soap:fault */
class SOAP_CMAC soap__fault
{
public:
	char *name;	/* optional attribute */
	char *encodingStyle;	/* optional attribute */
	enum soap__useChoice use;	/* optional attribute */
	char *namespace_;	/* optional attribute */
public:
	virtual int soap_type() const { return 223; } /* = unique type id SOAP_TYPE_soap__fault */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         soap__fault() { soap__fault::soap_default(NULL); }
	virtual ~soap__fault() { }
};
#endif

#ifndef SOAP_TYPE_soap__headerfault
#define SOAP_TYPE_soap__headerfault (224)
/* soap:headerfault */
class SOAP_CMAC soap__headerfault
{
public:
	char *message;	/* optional attribute */
	char *part;	/* optional attribute */
	enum soap__useChoice use;	/* optional attribute */
	char *encodingStyle;	/* optional attribute */
	char *namespace_;	/* optional attribute */
private:
	class wsdl__message *messageRef;	/* not serialized */
	class wsdl__part *partRef;	/* not serialized */
public:
	int traverse(class wsdl__definitions &_param_62);	/* transient */
	void messagePtr(wsdl__message *_param_63);	/* transient */
	void partPtr(wsdl__part *_param_64);	/* transient */
	wsdl__message *messagePtr() const;	/* transient */
	wsdl__part *partPtr() const;	/* transient */
public:
	virtual int soap_type() const { return 224; } /* = unique type id SOAP_TYPE_soap__headerfault */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         soap__headerfault() { soap__headerfault::soap_default(NULL); }
	virtual ~soap__headerfault() { }
};
#endif

#ifndef SOAP_TYPE_soap__header
#define SOAP_TYPE_soap__header (235)
/* soap:header */
class SOAP_CMAC soap__header
{
public:
	char *message;	/* optional attribute */
	char *part;	/* optional attribute */
	enum soap__useChoice use;	/* optional attribute */
	char *encodingStyle;	/* optional attribute */
	char *namespace_;	/* optional attribute */
	std::vector<soap__headerfault >headerfault;	/* optional element of type soap:headerfault */
private:
	wsdl__message *messageRef;	/* not serialized */
	wsdl__part *partRef;	/* not serialized */
public:
	int traverse(wsdl__definitions &_param_65);	/* transient */
	void messagePtr(wsdl__message *_param_66);	/* transient */
	void partPtr(wsdl__part *_param_67);	/* transient */
	wsdl__message *messagePtr() const;	/* transient */
	wsdl__part *partPtr() const;	/* transient */
public:
	virtual int soap_type() const { return 235; } /* = unique type id SOAP_TYPE_soap__header */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         soap__header() { soap__header::soap_default(NULL); }
	virtual ~soap__header() { }
};
#endif

#ifndef SOAP_TYPE_soap__address
#define SOAP_TYPE_soap__address (242)
/* soap:address */
class SOAP_CMAC soap__address
{
public:
	char *location;	/* optional attribute */
public:
	virtual int soap_type() const { return 242; } /* = unique type id SOAP_TYPE_soap__address */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         soap__address() { soap__address::soap_default(NULL); }
	virtual ~soap__address() { }
};
#endif

#ifndef SOAP_TYPE_wsoap__module
#define SOAP_TYPE_wsoap__module (243)
/* wsoap:module */
class SOAP_CMAC wsoap__module
{
public:
	char *ref;	/* optional attribute */
	bool required;	/* optional attribute */
public:
	virtual int soap_type() const { return 243; } /* = unique type id SOAP_TYPE_wsoap__module */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsoap__module() { wsoap__module::soap_default(NULL); }
	virtual ~wsoap__module() { }
};
#endif

#ifndef SOAP_TYPE_wsoap__header
#define SOAP_TYPE_wsoap__header (244)
/* wsoap:header */
class SOAP_CMAC wsoap__header
{
public:
	char *element;	/* optional attribute */
	bool mustUnderstand_;	/* optional attribute */
	bool required;	/* optional attribute */
private:
	xs__element *elementRef;	/* not serialized */
public:
	int traverse(wsdl__definitions &_param_68);	/* transient */
	void elementPtr(xs__element *_param_69);	/* transient */
	xs__element *elementPtr() const;	/* transient */
public:
	virtual int soap_type() const { return 244; } /* = unique type id SOAP_TYPE_wsoap__header */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsoap__header() { wsoap__header::soap_default(NULL); }
	virtual ~wsoap__header() { }
};
#endif

#ifndef SOAP_TYPE_mime__content
#define SOAP_TYPE_mime__content (248)
/* mime:content */
class SOAP_CMAC mime__content
{
public:
	char *part;	/* optional attribute */
	char *type;	/* optional attribute */
public:
	virtual int soap_type() const { return 248; } /* = unique type id SOAP_TYPE_mime__content */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         mime__content() { mime__content::soap_default(NULL); }
	virtual ~mime__content() { }
};
#endif

#ifndef SOAP_TYPE_mime__part
#define SOAP_TYPE_mime__part (249)
/* mime:part */
class SOAP_CMAC mime__part
{
public:
	soap__body *soap__body_;	/* optional element of type soap:body */
	std::vector<soap__header >soap__header_;	/* optional element of type soap:header */
	std::vector<mime__content >content;	/* optional element of type mime:content */
	int traverse(wsdl__definitions &_param_70);	/* transient */
public:
	virtual int soap_type() const { return 249; } /* = unique type id SOAP_TYPE_mime__part */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         mime__part() { mime__part::soap_default(NULL); }
	virtual ~mime__part() { }
};
#endif

#ifndef SOAP_TYPE_mime__multipartRelated
#define SOAP_TYPE_mime__multipartRelated (254)
/* mime:multipartRelated */
class SOAP_CMAC mime__multipartRelated
{
public:
	std::vector<mime__part >part;	/* optional element of type mime:part */
	int traverse(wsdl__definitions &_param_71);	/* transient */
public:
	virtual int soap_type() const { return 254; } /* = unique type id SOAP_TYPE_mime__multipartRelated */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         mime__multipartRelated() { mime__multipartRelated::soap_default(NULL); }
	virtual ~mime__multipartRelated() { }
};
#endif

#ifndef SOAP_TYPE_mime__mimeXml
#define SOAP_TYPE_mime__mimeXml (257)
/* mime:mimeXml */
class SOAP_CMAC mime__mimeXml
{
public:
	char *part;	/* optional attribute */
public:
	virtual int soap_type() const { return 257; } /* = unique type id SOAP_TYPE_mime__mimeXml */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         mime__mimeXml() { mime__mimeXml::soap_default(NULL); }
	virtual ~mime__mimeXml() { }
};
#endif

#ifndef SOAP_TYPE_dime__message
#define SOAP_TYPE_dime__message (258)
/* dime:message */
class SOAP_CMAC dime__message
{
public:
	char *layout;	/* optional attribute */
public:
	virtual int soap_type() const { return 258; } /* = unique type id SOAP_TYPE_dime__message */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         dime__message() { dime__message::soap_default(NULL); }
	virtual ~dime__message() { }
};
#endif

#ifndef SOAP_TYPE_http__address
#define SOAP_TYPE_http__address (259)
/* http:address */
class SOAP_CMAC http__address
{
public:
	char *location;	/* optional attribute */
public:
	virtual int soap_type() const { return 259; } /* = unique type id SOAP_TYPE_http__address */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         http__address() { http__address::soap_default(NULL); }
	virtual ~http__address() { }
};
#endif

#ifndef SOAP_TYPE_http__binding
#define SOAP_TYPE_http__binding (260)
/* http:binding */
class SOAP_CMAC http__binding
{
public:
	char *verb;	/* optional attribute */
public:
	virtual int soap_type() const { return 260; } /* = unique type id SOAP_TYPE_http__binding */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         http__binding() { http__binding::soap_default(NULL); }
	virtual ~http__binding() { }
};
#endif

#ifndef SOAP_TYPE_http__operation
#define SOAP_TYPE_http__operation (261)
/* http:operation */
class SOAP_CMAC http__operation
{
public:
	char *location;	/* optional attribute */
public:
	virtual int soap_type() const { return 261; } /* = unique type id SOAP_TYPE_http__operation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         http__operation() { http__operation::soap_default(NULL); }
	virtual ~http__operation() { }
};
#endif

#ifndef SOAP_TYPE_whttp__header
#define SOAP_TYPE_whttp__header (262)
/* whttp:header */
class SOAP_CMAC whttp__header
{
public:
	char *name;	/* optional attribute */
	char *type;	/* optional attribute */
	bool required;	/* optional attribute */
public:
	virtual int soap_type() const { return 262; } /* = unique type id SOAP_TYPE_whttp__header */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         whttp__header() { whttp__header::soap_default(NULL); }
	virtual ~whttp__header() { }
};
#endif

#ifndef SOAP_TYPE_sd__serviceData
#define SOAP_TYPE_sd__serviceData (265)
/* sd:serviceData */
class SOAP_CMAC sd__serviceData
{
public:
	char *name;	/* optional attribute */
	char *type;	/* optional attribute */
	bool nillable;	/* optional attribute */
	char *minOccurs;	/* optional attribute */
	char *maxOccurs;	/* optional attribute */
	enum sd__mutability mutability;	/* optional attribute */
	bool modifiable;	/* optional attribute */
public:
	virtual int soap_type() const { return 265; } /* = unique type id SOAP_TYPE_sd__serviceData */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         sd__serviceData() { sd__serviceData::soap_default(NULL); }
	virtual ~sd__serviceData() { }
};
#endif

#ifndef SOAP_TYPE_sd__staticServiceDataValues
#define SOAP_TYPE_sd__staticServiceDataValues (266)
/* sd:staticServiceDataValues */
class SOAP_CMAC sd__staticServiceDataValues
{
public:
	int __type;	/* any type of element <any> (defined below) */
	void *_any;	/* transient */
public:
	virtual int soap_type() const { return 266; } /* = unique type id SOAP_TYPE_sd__staticServiceDataValues */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         sd__staticServiceDataValues() { sd__staticServiceDataValues::soap_default(NULL); }
	virtual ~sd__staticServiceDataValues() { }
};
#endif

#ifndef SOAP_TYPE_gwsdl__portType
#define SOAP_TYPE_gwsdl__portType (268)
/* gwsdl:portType */
class SOAP_CMAC gwsdl__portType
{
public:
	char *name;	/* optional attribute */
	char *extends;	/* optional attribute */
	char *documentation;	/* optional element of type xsd:string */
	std::vector<class wsdl__operation * >operation;	/* optional element of type wsdl:operation */
	std::vector<sd__serviceData >sd__serviceData_;	/* optional element of type sd:serviceData */
	sd__staticServiceDataValues *sd__staticServiceDataValues_;	/* optional element of type sd:staticServiceDataValues */
public:
	virtual int soap_type() const { return 268; } /* = unique type id SOAP_TYPE_gwsdl__portType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         gwsdl__portType() { gwsdl__portType::soap_default(NULL); }
	virtual ~gwsdl__portType() { }
};
#endif

#ifndef SOAP_TYPE_wsa__EndpointReferenceType
#define SOAP_TYPE_wsa__EndpointReferenceType (273)
/* wsa:EndpointReferenceType */
class SOAP_CMAC wsa__EndpointReferenceType
{
public:
	char *Address;	/* optional element of type xsd:anyURI */
	char *__any;
public:
	virtual int soap_type() const { return 273; } /* = unique type id SOAP_TYPE_wsa__EndpointReferenceType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsa__EndpointReferenceType() { wsa__EndpointReferenceType::soap_default(NULL); }
	virtual ~wsa__EndpointReferenceType() { }
};
#endif





#ifndef SOAP_TYPE_wsp__PolicyReference
#define SOAP_TYPE_wsp__PolicyReference (278)
/* wsp:PolicyReference */
class SOAP_CMAC wsp__PolicyReference
{
public:
	char *URI;	/* optional attribute */
	char *Digest;	/* optional attribute */
	char *DigestAlgorithm;	/* optional attribute */
private:
	class wsp__Policy *policyRef;	/* not serialized */
public:
	int traverse(wsdl__definitions &_param_72);	/* transient */
	void policyPtr(wsp__Policy *_param_73);	/* transient */
	wsp__Policy *policyPtr() const;	/* transient */
public:
	virtual int soap_type() const { return 278; } /* = unique type id SOAP_TYPE_wsp__PolicyReference */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsp__PolicyReference() { wsp__PolicyReference::soap_default(NULL); }
	virtual ~wsp__PolicyReference() { }
};
#endif

#ifndef SOAP_TYPE_wsp__Assertion
#define SOAP_TYPE_wsp__Assertion (284)
/* wsp:Assertion */
class SOAP_CMAC wsp__Assertion
{
public:
	bool Optional;	/* optional attribute */
	bool Ignorable;	/* optional attribute */
	class wsp__Content *Policy;	/* optional element of type wsp:Content */
public:
	virtual int soap_type() const { return 284; } /* = unique type id SOAP_TYPE_wsp__Assertion */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsp__Assertion() { wsp__Assertion::soap_default(NULL); }
	virtual ~wsp__Assertion() { }
};
#endif

#ifndef SOAP_TYPE_wst__Claims
#define SOAP_TYPE_wst__Claims (286)
/* wst:Claims */
class SOAP_CMAC wst__Claims
{
public:
	char *Dialect;	/* optional attribute */
	char *__item;
public:
	virtual int soap_type() const { return 286; } /* = unique type id SOAP_TYPE_wst__Claims */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wst__Claims() { wst__Claims::soap_default(NULL); }
	virtual ~wst__Claims() { }
};
#endif

#ifndef SOAP_TYPE_sp__Header
#define SOAP_TYPE_sp__Header (287)
/* sp:Header */
class SOAP_CMAC sp__Header
{
public:
	char *Name;	/* optional attribute */
	char *Namespace;	/* optional attribute */
public:
	virtual int soap_type() const { return 287; } /* = unique type id SOAP_TYPE_sp__Header */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         sp__Header() { sp__Header::soap_default(NULL); }
	virtual ~sp__Header() { }
};
#endif

#ifndef SOAP_TYPE_sp__Parts
#define SOAP_TYPE_sp__Parts (288)
/* sp:Parts */
class SOAP_CMAC sp__Parts
{
public:
	char *Body;	/* optional element of type xsd:string */
	std::vector<sp__Header >Header;	/* optional element of type sp:Header */
	char *Attachments;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 288; } /* = unique type id SOAP_TYPE_sp__Parts */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         sp__Parts() { sp__Parts::soap_default(NULL); }
	virtual ~sp__Parts() { }
};
#endif

#ifndef SOAP_TYPE_sp__Elements
#define SOAP_TYPE_sp__Elements (290)
/* sp:Elements */
class SOAP_CMAC sp__Elements
{
public:
	char *XPathVersion;	/* optional attribute */
	std::vector<char * >XPath;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 290; } /* = unique type id SOAP_TYPE_sp__Elements */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         sp__Elements() { sp__Elements::soap_default(NULL); }
	virtual ~sp__Elements() { }
};
#endif

#ifndef SOAP_TYPE_sp__Token
#define SOAP_TYPE_sp__Token (292)
/* sp:Token */
class SOAP_CMAC sp__Token : public wsp__Assertion
{
public:
	char *IncludeToken;	/* optional attribute */
	wsa__EndpointReferenceType *Issuer;	/* optional element of type wsa:EndpointReferenceType */
	char *IssuerName;	/* optional element of type xsd:anyURI */
	wst__Claims *wst__Claims_;	/* optional element of type wst:Claims */
public:
	virtual int soap_type() const { return 292; } /* = unique type id SOAP_TYPE_sp__Token */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         sp__Token() { sp__Token::soap_default(NULL); }
	virtual ~sp__Token() { }
};
#endif

#ifndef SOAP_TYPE_wsrmp__Timeout
#define SOAP_TYPE_wsrmp__Timeout (295)
/* wsrmp:Timeout */
class SOAP_CMAC wsrmp__Timeout
{
public:
	char *Milliseconds;	/* optional attribute */
public:
	virtual int soap_type() const { return 295; } /* = unique type id SOAP_TYPE_wsrmp__Timeout */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsrmp__Timeout() { wsrmp__Timeout::soap_default(NULL); }
	virtual ~wsrmp__Timeout() { }
};
#endif

#ifndef SOAP_TYPE_wsrmp__RMAssertion
#define SOAP_TYPE_wsrmp__RMAssertion (296)
/* wsrmp:RMAssertion */
class SOAP_CMAC wsrmp__RMAssertion : public wsp__Assertion
{
public:
	wsrmp__Timeout *InactivityTimeout;	/* optional element of type wsrmp:Timeout */
	wsrmp__Timeout *BaseRetransmissionInterval;	/* optional element of type wsrmp:Timeout */
	wsrmp__Timeout *AcknowledgementInterval;	/* optional element of type wsrmp:Timeout */
	char *ExponentialBackoff;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 296; } /* = unique type id SOAP_TYPE_wsrmp__RMAssertion */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsrmp__RMAssertion() { wsrmp__RMAssertion::soap_default(NULL); }
	virtual ~wsrmp__RMAssertion() { }
};
#endif

#ifndef SOAP_TYPE_wsp__Content
#define SOAP_TYPE_wsp__Content (275)
/* wsp:Content */
class SOAP_CMAC wsp__Content
{
public:
	wsp__Policy *Policy;	/* optional element of type wsp:Policy */
	wsp__PolicyReference *PolicyReference;	/* optional element of type wsp:PolicyReference */
	std::vector<wsp__Content * >All;	/* optional element of type wsp:Content */
	std::vector<wsp__Content * >ExactlyOne;	/* optional element of type wsp:Content */
	std::vector<sp__Parts >sp__SignedParts;	/* optional element of type sp:Parts */
	std::vector<sp__Parts >sp__EncryptedParts;	/* optional element of type sp:Parts */
	std::vector<sp__Parts >sp__RequiredParts;	/* optional element of type sp:Parts */
	sp__Elements *sp__SignedElements;	/* optional element of type sp:Elements */
	sp__Elements *sp__EncryptedElements;	/* optional element of type sp:Elements */
	sp__Elements *sp__ContentEncryptedElements;	/* optional element of type sp:Elements */
	sp__Elements *sp__RequiredElements;	/* optional element of type sp:Elements */
	sp__Token *sp__UsernameToken;	/* optional element of type sp:Token */
	sp__Token *sp__IssuedToken;	/* optional element of type sp:Token */
	sp__Token *sp__X509Token;	/* optional element of type sp:Token */
	sp__Token *sp__KerberosToken;	/* optional element of type sp:Token */
	sp__Token *sp__SpnegoContextToken;	/* optional element of type sp:Token */
	sp__Token *sp__SecurityContextToken;	/* optional element of type sp:Token */
	sp__Token *sp__SecureConversationToken;	/* optional element of type sp:Token */
	sp__Token *sp__SamlToken;	/* optional element of type sp:Token */
	sp__Token *sp__RelToken;	/* optional element of type sp:Token */
	sp__Token *sp__HttpsToken;	/* optional element of type sp:Token */
	sp__Token *sp__KeyValueToken;	/* optional element of type sp:Token */
	wsp__Assertion *sp__TransportBinding;	/* optional element of type wsp:Assertion */
	wsp__Assertion *sp__TransportToken;	/* optional element of type wsp:Assertion */
	wsp__Assertion *sp__AlgorithmSuite;	/* optional element of type wsp:Assertion */
	wsp__Assertion *sp__Layout;	/* optional element of type wsp:Assertion */
	wsp__Assertion *sp__SymmetricBinding;	/* optional element of type wsp:Assertion */
	wsp__Assertion *sp__AsymmetricBinding;	/* optional element of type wsp:Assertion */
	wsp__Assertion *sp__ProtectionToken;	/* optional element of type wsp:Assertion */
	wsp__Assertion *sp__InitiatorToken;	/* optional element of type wsp:Assertion */
	wsp__Assertion *sp__InitiatorSignatureToken;	/* optional element of type wsp:Assertion */
	wsp__Assertion *sp__InitiatorEncryptionToken;	/* optional element of type wsp:Assertion */
	wsp__Assertion *sp__RecipientToken;	/* optional element of type wsp:Assertion */
	wsp__Assertion *sp__SupportingTokens;	/* optional element of type wsp:Assertion */
	wsp__Assertion *sp__SignedSupportingTokens;	/* optional element of type wsp:Assertion */
	wsp__Assertion *sp__EndorsingSupportingTokens;	/* optional element of type wsp:Assertion */
	wsp__Assertion *sp__SignedEndorsingSupportingTokens;	/* optional element of type wsp:Assertion */
	wsp__Assertion *sp__SignedEncryptedSupportingTokens;	/* optional element of type wsp:Assertion */
	wsp__Assertion *sp__EncryptedSupportingTokens;	/* optional element of type wsp:Assertion */
	wsp__Assertion *sp__EndorsingEncryptedSupportingTokens;	/* optional element of type wsp:Assertion */
	wsp__Assertion *sp__SignedEndorsingEncryptedSupportingTokens;	/* optional element of type wsp:Assertion */
	wsp__Assertion *sp__Wss10;	/* optional element of type wsp:Assertion */
	wsp__Assertion *sp__Wss11;	/* optional element of type wsp:Assertion */
	wsp__Assertion *sp__Trust10;	/* optional element of type wsp:Assertion */
	wsp__Assertion *sp__Trust13;	/* optional element of type wsp:Assertion */
	wsp__Content *sp__BootstrapPolicy;	/* optional element of type wsp:Content */
	char *wsaw__UsingAddressing;	/* optional element of type xsd:string */
	wsp__Assertion *wsam__Addressing;	/* optional element of type wsp:Assertion */
	wsrmp__RMAssertion *wsrmp__RMAssertion_;	/* optional element of type wsrmp:RMAssertion */
	wsrmp__RMAssertion *wsrmp__DeliveryAssurance;	/* optional element of type wsrmp:RMAssertion */
	char *wsrmp__AtLeastOnce;	/* optional element of type xsd:string */
	char *wsrmp__AtMostOnce;	/* optional element of type xsd:string */
	char *wsrmp__ExactlyOnce;	/* optional element of type xsd:string */
	char *wsrmp__InOrder;	/* optional element of type xsd:string */
	wsp__Assertion *sp__NoPassword;	/* optional element of type wsp:Assertion */
	wsp__Assertion *sp__HashPassword;	/* optional element of type wsp:Assertion */
	wsp__Assertion *sp__IncludeTimestamp;	/* optional element of type wsp:Assertion */
	wsp__Assertion *sp__EncryptBeforeSigning;	/* optional element of type wsp:Assertion */
	wsp__Assertion *sp__EncryptSignature;	/* optional element of type wsp:Assertion */
	wsp__Assertion *sp__ProtectTokens;	/* optional element of type wsp:Assertion */
	wsp__Assertion *sp__OnlySignEntireHeadersAndBody;	/* optional element of type wsp:Assertion */
	char *sp__RequireDerivedKeys;	/* optional element of type xsd:string */
	char *sp__RequireImpliedDerivedKeys;	/* optional element of type xsd:string */
	char *sp__RequireExplicitDerivedKeys;	/* optional element of type xsd:string */
	char *sp__WssUsernameToken10;	/* optional element of type xsd:string */
	char *sp__WssUsernameToken11;	/* optional element of type xsd:string */
	char *sp__RequireExternalReference;	/* optional element of type xsd:string */
	char *sp__RequireInternalReference;	/* optional element of type xsd:string */
	char *sp__RequireKeyIdentifierReference;	/* optional element of type xsd:string */
	char *sp__RequireIssuerSerialReference;	/* optional element of type xsd:string */
	char *sp__RequireEmbeddedTokenReference;	/* optional element of type xsd:string */
	char *sp__RequireThumbprintReference;	/* optional element of type xsd:string */
	char *sp__WssX509V3Token10;	/* optional element of type xsd:string */
	char *sp__WssX509Pkcs7Token10;	/* optional element of type xsd:string */
	char *sp__WssX509PkiPathV1Token10;	/* optional element of type xsd:string */
	char *sp__WssX509V1Token11;	/* optional element of type xsd:string */
	char *sp__WssX509V3Token11;	/* optional element of type xsd:string */
	char *sp__WssX509Pkcs7Token11;	/* optional element of type xsd:string */
	char *sp__WssX509PkiPathV1Token11;	/* optional element of type xsd:string */
	char *sp__WssKerberosV5ApReqToken11;	/* optional element of type xsd:string */
	char *sp__WssGssKerberosV5ApReqToken11;	/* optional element of type xsd:string */
	char *sp__WssRelV10Token10;	/* optional element of type xsd:string */
	char *sp__WssRelV20Token10;	/* optional element of type xsd:string */
	char *sp__WssRelV10Token11;	/* optional element of type xsd:string */
	char *sp__WssRelV20Token11;	/* optional element of type xsd:string */
	char *sp__MustNotSendCancel;	/* optional element of type xsd:string */
	char *sp__MustNotSendAmend;	/* optional element of type xsd:string */
	char *sp__MustNotSendRenew;	/* optional element of type xsd:string */
	char *sp__MustSupportRefKeyIdentifier;	/* optional element of type xsd:string */
	char *sp__MustSupportRefIssuerSerial;	/* optional element of type xsd:string */
	char *sp__MustSupportRefExternalURI;	/* optional element of type xsd:string */
	char *sp__MustSupportRefEmbeddedToken;	/* optional element of type xsd:string */
	char *sp__MustSupportRefThumbprint;	/* optional element of type xsd:string */
	char *sp__MustSupportRefEncryptedKey;	/* optional element of type xsd:string */
	char *sp__RequireSignatureConfirmation;	/* optional element of type xsd:string */
	char *sp__MustSupportClientChallenge;	/* optional element of type xsd:string */
	char *sp__MustSupportServerChallenge;	/* optional element of type xsd:string */
	char *sp__RequireClientEntropy;	/* optional element of type xsd:string */
	char *sp__RequireServerEntropy;	/* optional element of type xsd:string */
	char *sp__MustSupportIssuedTokens;	/* optional element of type xsd:string */
	char *sp__RequireRequestSecurityTokenCollection;	/* optional element of type xsd:string */
	char *sp__RequireAppliesTo;	/* optional element of type xsd:string */
	char *sp__RequireExternalUriReference;	/* optional element of type xsd:string */
	char *sp__SC13SecurityContextToken;	/* optional element of type xsd:string */
	char *sp__Strict;	/* optional element of type xsd:string */
	char *sp__Lax;	/* optional element of type xsd:string */
	char *sp__LaxTsFirst;	/* optional element of type xsd:string */
	char *sp__LaxTsLast;	/* optional element of type xsd:string */
	char *sp__HttpBasicAuthentication;	/* optional element of type xsd:string */
	char *sp__HttpDigestAuthentication;	/* optional element of type xsd:string */
	char *sp__RequireClientCertificate;	/* optional element of type xsd:string */
	char *sp__Basic256;	/* optional element of type xsd:string */
	char *sp__Basic192;	/* optional element of type xsd:string */
	char *sp__Basic128;	/* optional element of type xsd:string */
	char *sp__TripleDes;	/* optional element of type xsd:string */
	char *sp__Basic256Rsa15;	/* optional element of type xsd:string */
	char *sp__Basic192Rsa15;	/* optional element of type xsd:string */
	char *sp__Basic128Rsa15;	/* optional element of type xsd:string */
	char *sp__TripleDesRsa15;	/* optional element of type xsd:string */
	char *sp__Basic256Sha256;	/* optional element of type xsd:string */
	char *sp__Basic192Sha256;	/* optional element of type xsd:string */
	char *sp__Basic128Sha256;	/* optional element of type xsd:string */
	char *sp__TripleDesSha256;	/* optional element of type xsd:string */
	char *sp__Basic256Sha256Rsa15;	/* optional element of type xsd:string */
	char *sp__Basic192Sha256Rsa15;	/* optional element of type xsd:string */
	char *sp__Basic128Sha256Rsa15;	/* optional element of type xsd:string */
	char *sp__TripleDesSha256Rsa15;	/* optional element of type xsd:string */
	char *sp__InclusiveC14N;	/* optional element of type xsd:string */
	char *sp__SOAPNormalization10;	/* optional element of type xsd:string */
	char *sp__STRTransform10;	/* optional element of type xsd:string */
	char *sp__Path10;	/* optional element of type xsd:string */
	char *sp__XPathFilter20;	/* optional element of type xsd:string */
	char *sp__AbsXPath;	/* optional element of type xsd:string */
	char *wsam__AnonymousResponses;	/* optional element of type xsd:string */
	char *wsam__NonAnonymousResponses;	/* optional element of type xsd:string */
	std::vector<char * >__any;
	int traverse(wsdl__definitions &_param_74);	/* transient */
	void generate(Service &service, Types &types, int indent) const;	/* transient */
public:
	virtual int soap_type() const { return 275; } /* = unique type id SOAP_TYPE_wsp__Content */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsp__Content() { wsp__Content::soap_default(NULL); }
	virtual ~wsp__Content() { }
};
#endif

#ifndef SOAP_TYPE_wsp__Policy
#define SOAP_TYPE_wsp__Policy (274)
/* wsp:Policy */
class SOAP_CMAC wsp__Policy : public wsp__Content
{
public:
	char *xml__base;	/* optional attribute */
	char *wsu__Id;	/* optional attribute */
	char *TargetNamespace;	/* optional attribute */
public:
	virtual int soap_type() const { return 274; } /* = unique type id SOAP_TYPE_wsp__Policy */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsp__Policy() { wsp__Policy::soap_default(NULL); }
	virtual ~wsp__Policy() { }
};
#endif

#ifndef SOAP_TYPE_wsp__Attachment
#define SOAP_TYPE_wsp__Attachment (310)
/* wsp:Attachment */
class SOAP_CMAC wsp__Attachment
{
public:
	wsp__Policy *Policy;	/* optional element of type wsp:Policy */
	wsp__PolicyReference *PolicyReference;	/* optional element of type wsp:PolicyReference */
public:
	virtual int soap_type() const { return 310; } /* = unique type id SOAP_TYPE_wsp__Attachment */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsp__Attachment() { wsp__Attachment::soap_default(NULL); }
	virtual ~wsp__Attachment() { }
};
#endif

#ifndef SOAP_TYPE_wsp__AppliesTo
#define SOAP_TYPE_wsp__AppliesTo (311)
/* wsp:AppliesTo */
class SOAP_CMAC wsp__AppliesTo
{
public:
	char *__any;
public:
	virtual int soap_type() const { return 311; } /* = unique type id SOAP_TYPE_wsp__AppliesTo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsp__AppliesTo() { wsp__AppliesTo::soap_default(NULL); }
	virtual ~wsp__AppliesTo() { }
};
#endif

#ifndef SOAP_TYPE_wsp__PolicyAttachment
#define SOAP_TYPE_wsp__PolicyAttachment (312)
/* wsp:PolicyAttachment */
class SOAP_CMAC wsp__PolicyAttachment
{
public:
	wsp__AppliesTo *AppliesTo;	/* optional element of type wsp:AppliesTo */
	std::vector<wsp__Attachment >Attachment;	/* optional element of type wsp:Attachment */
public:
	virtual int soap_type() const { return 312; } /* = unique type id SOAP_TYPE_wsp__PolicyAttachment */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsp__PolicyAttachment() { wsp__PolicyAttachment::soap_default(NULL); }
	virtual ~wsp__PolicyAttachment() { }
};
#endif

#ifndef SOAP_TYPE_wsdl__import
#define SOAP_TYPE_wsdl__import (315)
/* wsdl:import */
class SOAP_CMAC wsdl__import
{
public:
	char *namespace_;	/* optional attribute */
	char *location;	/* optional attribute */
private:
	wsdl__definitions *definitionsRef;	/* not serialized */
public:
	wsdl__import();	/* transient */
	int preprocess(wsdl__definitions &_param_75);	/* transient */
	int traverse(wsdl__definitions &_param_76);	/* transient */
	void definitionsPtr(wsdl__definitions *_param_77);	/* transient */
	wsdl__definitions *definitionsPtr() const;	/* transient */
public:
	virtual int soap_type() const { return 315; } /* = unique type id SOAP_TYPE_wsdl__import */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~wsdl__import() { }
};
#endif

#ifndef SOAP_TYPE_wsdl__types
#define SOAP_TYPE_wsdl__types (323)
/* wsdl:types */
class SOAP_CMAC wsdl__types : public xs__schema
{
public:
	char *documentation;	/* optional element of type xsd:string */
	std::vector<xs__schema * >xs__schema_;	/* optional element of type xs:schema */
	int preprocess(wsdl__definitions &_param_78);	/* transient */
	int traverse(wsdl__definitions &_param_79);	/* transient */
public:
	virtual int soap_type() const { return 323; } /* = unique type id SOAP_TYPE_wsdl__types */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsdl__types() { wsdl__types::soap_default(NULL); }
};
#endif

#ifndef SOAP_TYPE_wsdl__part
#define SOAP_TYPE_wsdl__part (216)
/* wsdl:part */
class SOAP_CMAC wsdl__part
{
public:
	char *name;	/* optional attribute */
	char *element;	/* optional attribute */
	char *type;	/* optional attribute */
	char *documentation;	/* optional element of type xsd:string */
private:
	xs__element *elementRef;	/* not serialized */
	xs__simpleType *simpleTypeRef;	/* not serialized */
	xs__complexType *complexTypeRef;	/* not serialized */
public:
	wsdl__part();	/* transient */
	int traverse(wsdl__definitions &_param_80);	/* transient */
	void elementPtr(xs__element *_param_81);	/* transient */
	void simpleTypePtr(xs__simpleType *_param_82);	/* transient */
	void complexTypePtr(xs__complexType *_param_83);	/* transient */
	xs__element *elementPtr() const;	/* transient */
	xs__simpleType *simpleTypePtr() const;	/* transient */
	xs__complexType *complexTypePtr() const;	/* transient */
public:
	virtual int soap_type() const { return 216; } /* = unique type id SOAP_TYPE_wsdl__part */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~wsdl__part() { }
};
#endif

#ifndef SOAP_TYPE_wsdl__message
#define SOAP_TYPE_wsdl__message (215)
/* wsdl:message */
class SOAP_CMAC wsdl__message
{
public:
	char *name;	/* optional attribute */
	char *documentation;	/* optional element of type xsd:string */
	std::vector<wsp__Policy >wsp__Policy_;	/* optional element of type wsp:Policy */
	std::vector<wsp__PolicyReference >wsp__PolicyReference_;	/* optional element of type wsp:PolicyReference */
	std::vector<wsdl__part >part;	/* optional element of type wsdl:part */
	int traverse(wsdl__definitions &_param_84);	/* transient */
public:
	virtual int soap_type() const { return 215; } /* = unique type id SOAP_TYPE_wsdl__message */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsdl__message() { wsdl__message::soap_default(NULL); }
	virtual ~wsdl__message() { }
};
#endif

#ifndef SOAP_TYPE_wsdl__ioput
#define SOAP_TYPE_wsdl__ioput (339)
/* wsdl:ioput */
class SOAP_CMAC wsdl__ioput
{
public:
	char *name;	/* optional attribute */
	char *message;	/* optional attribute */
	char *messageLabel;	/* optional attribute */
	char *element;	/* optional attribute */
	char *wsa__Action;	/* optional attribute */
	char *wsam__Action;	/* optional attribute */
	char *documentation;	/* optional element of type xsd:string */
	wsp__Policy *wsp__Policy_;	/* optional element of type wsp:Policy */
	wsp__PolicyReference *wsp__PolicyReference_;	/* optional element of type wsp:PolicyReference */
private:
	wsdl__message *messageRef;	/* not serialized */
	xs__element *elementRef;	/* not serialized */
public:
	wsdl__ioput();	/* transient */
	int traverse(wsdl__definitions &_param_85);	/* transient */
	void messagePtr(wsdl__message *_param_86);	/* transient */
	wsdl__message *messagePtr() const;	/* transient */
	void elementPtr(xs__element *_param_87);	/* transient */
	xs__element *elementPtr() const;	/* transient */
public:
	virtual int soap_type() const { return 339; } /* = unique type id SOAP_TYPE_wsdl__ioput */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~wsdl__ioput() { }
};
#endif

#ifndef SOAP_TYPE_wsdl__fault
#define SOAP_TYPE_wsdl__fault (346)
/* wsdl:fault */
class SOAP_CMAC wsdl__fault
{
public:
	char *name;	/* optional attribute */
	char *message;	/* optional attribute */
	char *ref;	/* optional attribute */
	char *messageLabel;	/* optional attribute */
	char *element;	/* optional attribute */
	char *wsa__Action;	/* optional attribute */
	char *wsam__Action;	/* optional attribute */
	char *documentation;	/* optional element of type xsd:string */
	wsp__Policy *wsp__Policy_;	/* optional element of type wsp:Policy */
	wsp__PolicyReference *wsp__PolicyReference_;	/* optional element of type wsp:PolicyReference */
private:
	wsdl__message *messageRef;	/* not serialized */
	xs__element *elementRef;	/* not serialized */
public:
	wsdl__fault();	/* transient */
	int traverse(wsdl__definitions &_param_88);	/* transient */
	void messagePtr(wsdl__message *_param_89);	/* transient */
	wsdl__message *messagePtr() const;	/* transient */
	void elementPtr(xs__element *_param_90);	/* transient */
	xs__element *elementPtr() const;	/* transient */
public:
	virtual int soap_type() const { return 346; } /* = unique type id SOAP_TYPE_wsdl__fault */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~wsdl__fault() { }
};
#endif

#ifndef SOAP_TYPE_wsdl__union_ioput
#define SOAP_TYPE_wsdl__union_ioput (354)
/* xsd:choice */
union wsdl__union_ioput
{
#define SOAP_UNION_wsdl__union_ioput_input	(1)
	wsdl__ioput *input;
#define SOAP_UNION_wsdl__union_ioput_output	(2)
	wsdl__ioput *output;
};
#endif

#ifndef SOAP_TYPE_wsdl__operation
#define SOAP_TYPE_wsdl__operation (263)
/* wsdl:operation */
class SOAP_CMAC wsdl__operation
{
public:
	char *name;	/* optional attribute */
	char *pattern;	/* optional attribute */
	char *style;	/* optional attribute */
	char *wrpc__signature;	/* optional attribute */
	char *parameterOrder;	/* optional attribute */
	char *documentation;	/* optional element of type xsd:string */
	wsp__Policy *wsp__Policy_;	/* optional element of type wsp:Policy */
	wsp__PolicyReference *wsp__PolicyReference_;	/* optional element of type wsp:PolicyReference */
	int __union1;	/* union discriminant (of union defined below) */
	union wsdl__union_ioput __ioput1;
	int __union2;	/* union discriminant (of union defined below) */
	union wsdl__union_ioput __ioput2;
	std::vector<wsdl__fault >fault;	/* optional element of type wsdl:fault */
	std::vector<wsdl__fault >infault;	/* optional element of type wsdl:fault */
	std::vector<wsdl__fault >outfault;	/* optional element of type wsdl:fault */
	int traverse(wsdl__definitions &_param_91);	/* transient */
public:
	virtual int soap_type() const { return 263; } /* = unique type id SOAP_TYPE_wsdl__operation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsdl__operation() { wsdl__operation::soap_default(NULL); }
	virtual ~wsdl__operation() { }
};
#endif

#ifndef SOAP_TYPE_wsdl__portType
#define SOAP_TYPE_wsdl__portType (357)
/* wsdl:portType */
class SOAP_CMAC wsdl__portType
{
public:
	char *name;	/* optional attribute */
	char *extends;	/* optional attribute */
	char *styleDefault;	/* optional attribute */
	char *documentation;	/* optional element of type xsd:string */
	wsp__Policy *wsp__Policy_;	/* optional element of type wsp:Policy */
	wsp__PolicyReference *wsp__PolicyReference_;	/* optional element of type wsp:PolicyReference */
	std::vector<wsdl__fault >fault;	/* optional element of type wsdl:fault */
	std::vector<wsdl__operation >operation;	/* optional element of type wsdl:operation */
private:
	wsdl__definitions *definitionsRef;	/* not serialized */
public:
	wsdl__portType();	/* transient */
	int traverse(wsdl__definitions &_param_92);	/* transient */
	void definitionsPtr(wsdl__definitions *_param_93);	/* transient */
	wsdl__definitions *definitionsPtr() const;	/* transient */
public:
	virtual int soap_type() const { return 357; } /* = unique type id SOAP_TYPE_wsdl__portType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~wsdl__portType() { }
};
#endif

#ifndef SOAP_TYPE_wsdl__ext_ioput
#define SOAP_TYPE_wsdl__ext_ioput (363)
/* wsdl:ext-ioput */
class SOAP_CMAC wsdl__ext_ioput
{
public:
	char *name;	/* optional attribute */
	char *messageLabel;	/* optional attribute */
	char *documentation;	/* optional element of type xsd:string */
	wsp__Policy *wsp__Policy_;	/* optional element of type wsp:Policy */
	wsp__PolicyReference *wsp__PolicyReference_;	/* optional element of type wsp:PolicyReference */
	dime__message *dime__message_;	/* optional element of type dime:message */
	soap__body *soap__body_;	/* optional element of type soap:body */
	char *http__urlEncoded;	/* optional element of type xsd:string */
	mime__multipartRelated *mime__multipartRelated_;	/* optional element of type mime:multipartRelated */
	mime__content *mime__content_;	/* optional element of type mime:content */
	mime__mimeXml *mime__mimeXml_;	/* optional element of type mime:mimeXml */
	std::vector<soap__header >soap__header_;	/* optional element of type soap:header */
	std::vector<wsoap__module >wsoap__module_;	/* optional element of type wsoap:module */
	std::vector<wsoap__header >wsoap__header_;	/* optional element of type wsoap:header */
	std::vector<whttp__header >whttp__header_;	/* optional element of type whttp:header */
	int traverse(wsdl__definitions &_param_94);	/* transient */
public:
	virtual int soap_type() const { return 363; } /* = unique type id SOAP_TYPE_wsdl__ext_ioput */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsdl__ext_ioput() { wsdl__ext_ioput::soap_default(NULL); }
	virtual ~wsdl__ext_ioput() { }
};
#endif

#ifndef SOAP_TYPE_wsdl__ext_fault
#define SOAP_TYPE_wsdl__ext_fault (372)
/* wsdl:ext-fault */
class SOAP_CMAC wsdl__ext_fault
{
public:
	char *name;	/* optional attribute */
	char *ref;	/* optional attribute */
	char *messageLabel;	/* optional attribute */
	char *wsoap__code;	/* optional attribute */
	char *wsoap__subcodes;	/* optional attribute */
	char *documentation;	/* optional element of type xsd:string */
	wsp__Policy *wsp__Policy_;	/* optional element of type wsp:Policy */
	wsp__PolicyReference *wsp__PolicyReference_;	/* optional element of type wsp:PolicyReference */
	soap__fault *soap__fault_;	/* optional element of type soap:fault */
	std::vector<wsoap__module >wsoap__module_;	/* optional element of type wsoap:module */
private:
	wsdl__fault *faultRef;	/* not serialized */
public:
	wsdl__ext_fault();	/* transient */
	int traverse(wsdl__definitions &_param_95, wsdl__portType *_param_96);	/* transient */
	void faultPtr(wsdl__fault *_param_97);	/* transient */
	wsdl__fault *faultPtr() const;	/* transient */
public:
	virtual int soap_type() const { return 372; } /* = unique type id SOAP_TYPE_wsdl__ext_fault */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~wsdl__ext_fault() { }
};
#endif

#ifndef SOAP_TYPE_wsdl__ext_operation
#define SOAP_TYPE_wsdl__ext_operation (381)
/* wsdl:ext-operation */
class SOAP_CMAC wsdl__ext_operation
{
public:
	char *name;	/* optional attribute */
	char *ref;	/* optional attribute */
	char *wsoap__mep;	/* optional attribute */
	char *wsoap__action;	/* optional attribute */
	char *whttp__method;	/* optional attribute */
	char *whttp__location;	/* optional attribute */
	char *documentation;	/* optional element of type xsd:string */
	wsp__Policy *wsp__Policy_;	/* optional element of type wsp:Policy */
	wsp__PolicyReference *wsp__PolicyReference_;	/* optional element of type wsp:PolicyReference */
	soap__operation *soap__operation_;	/* optional element of type soap:operation */
	http__operation *http__operation_;	/* optional element of type http:operation */
	wsdl__ext_ioput *input;	/* optional element of type wsdl:ext-ioput */
	wsdl__ext_ioput *output;	/* optional element of type wsdl:ext-ioput */
	std::vector<wsdl__ext_fault >fault;	/* optional element of type wsdl:ext-fault */
	std::vector<wsdl__ext_fault >infault;	/* optional element of type wsdl:ext-fault */
	std::vector<wsdl__ext_fault >outfault;	/* optional element of type wsdl:ext-fault */
private:
	wsdl__operation *operationRef;	/* not serialized */
public:
	wsdl__ext_operation();	/* transient */
	int traverse(wsdl__definitions &_param_98, wsdl__portType *_param_99);	/* transient */
	void operationPtr(wsdl__operation *_param_100);	/* transient */
	wsdl__operation *operationPtr() const;	/* transient */
public:
	virtual int soap_type() const { return 381; } /* = unique type id SOAP_TYPE_wsdl__ext_operation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~wsdl__ext_operation() { }
};
#endif

#ifndef SOAP_TYPE_wsdl__binding
#define SOAP_TYPE_wsdl__binding (391)
/* wsdl:binding */
class SOAP_CMAC wsdl__binding
{
public:
	char *name;	/* optional attribute */
	char *type;	/* optional attribute */
	char *type_;	/* optional attribute */
	char *interface_;	/* optional attribute */
	bool whttp__cookies;	/* optional attribute */
	char *wsoap__version;	/* optional attribute */
	char *wsoap__protocol;	/* optional attribute */
	char *wsoap__mepDefault;	/* optional attribute */
	char *whttp__methodDefault;	/* optional attribute */
	char *documentation;	/* optional element of type xsd:string */
	std::vector<wsp__Policy >wsp__Policy_;	/* optional element of type wsp:Policy */
	std::vector<wsp__PolicyReference >wsp__PolicyReference_;	/* optional element of type wsp:PolicyReference */
	soap__binding *soap__binding_;	/* optional element of type soap:binding */
	http__binding *http__binding_;	/* optional element of type http:binding */
	std::vector<wsoap__module >wsoap__module_;	/* optional element of type wsoap:module */
	std::vector<wsdl__ext_fault >fault;	/* optional element of type wsdl:ext-fault */
	std::vector<wsdl__ext_operation >operation;	/* optional element of type wsdl:ext-operation */
private:
	wsdl__portType *portTypeRef;	/* not serialized */
public:
	wsdl__binding();	/* transient */
	int traverse(wsdl__definitions &_param_101);	/* transient */
	void portTypePtr(wsdl__portType *_param_102);	/* transient */
	wsdl__portType *portTypePtr() const;	/* transient */
public:
	virtual int soap_type() const { return 391; } /* = unique type id SOAP_TYPE_wsdl__binding */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~wsdl__binding() { }
};
#endif

#ifndef SOAP_TYPE_wsdl__port
#define SOAP_TYPE_wsdl__port (400)
/* wsdl:port */
class SOAP_CMAC wsdl__port
{
public:
	char *name;	/* optional attribute */
	char *binding;	/* optional attribute */
	char *address;	/* optional attribute */
	char *whttp__authenticationScheme;	/* optional attribute */
	char *whttp__authenticationRealm;	/* optional attribute */
	char *documentation;	/* optional element of type xsd:string */
	wsp__Policy *wsp__Policy_;	/* optional element of type wsp:Policy */
	wsp__PolicyReference *wsp__PolicyReference_;	/* optional element of type wsp:PolicyReference */
	wsa__EndpointReferenceType *wsa__EndpointReference;	/* optional element of type wsa:EndpointReferenceType */
	soap__address *soap__address_;	/* optional element of type soap:address */
	http__address *http__address_;	/* optional element of type http:address */
private:
	wsdl__binding *bindingRef;	/* not serialized */
public:
	wsdl__port();	/* transient */
	int traverse(wsdl__definitions &_param_103);	/* transient */
	void bindingPtr(wsdl__binding *_param_104);	/* transient */
	wsdl__binding *bindingPtr() const;	/* transient */
public:
	virtual int soap_type() const { return 400; } /* = unique type id SOAP_TYPE_wsdl__port */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~wsdl__port() { }
};
#endif

#ifndef SOAP_TYPE_wsdl__service
#define SOAP_TYPE_wsdl__service (409)
/* wsdl:service */
class SOAP_CMAC wsdl__service
{
public:
	char *name;	/* optional attribute */
	char *interface_;	/* optional attribute */
	char *documentation;	/* optional element of type xsd:string */
	std::vector<wsp__Policy >wsp__Policy_;	/* optional element of type wsp:Policy */
	std::vector<wsp__PolicyReference >wsp__PolicyReference_;	/* optional element of type wsp:PolicyReference */
	std::vector<wsdl__port >port;	/* optional element of type wsdl:port */
	std::vector<wsdl__port >endpoint;	/* optional element of type wsdl:port */
	int traverse(wsdl__definitions &_param_105);	/* transient */
public:
	virtual int soap_type() const { return 409; } /* = unique type id SOAP_TYPE_wsdl__service */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsdl__service() { wsdl__service::soap_default(NULL); }
	virtual ~wsdl__service() { }
};
#endif

#ifndef SOAP_TYPE_wsdl__definitions
#define SOAP_TYPE_wsdl__definitions (214)
/* wsdl:definitions */
class SOAP_CMAC wsdl__definitions
{
public:
	char *name;	/* optional attribute */
	char *targetNamespace;	/* optional attribute */
	char *version;	/* optional attribute */
	std::vector<wsdl__import >import;	/* optional element of type wsdl:import */
	char *documentation;	/* optional element of type xsd:string */
	char *wsp__UsingPolicy;	/* optional element of type xsd:string */
	std::vector<wsp__Policy >wsp__Policy_;	/* optional element of type wsp:Policy */
	wsdl__types *types;	/* optional element of type wsdl:types */
	std::vector<wsdl__message >message;	/* optional element of type wsdl:message */
	std::vector<wsdl__portType >portType;	/* optional element of type wsdl:portType */
	std::vector<wsdl__portType >interface_;	/* optional element of type wsdl:portType */
	std::vector<wsdl__binding >binding;	/* optional element of type wsdl:binding */
	std::vector<wsdl__service >service;	/* optional element of type wsdl:service */
	std::vector<gwsdl__portType >gwsdl__portType_;	/* optional element of type gwsdl:portType */
	struct soap *soap;	/* transient */
private:
	bool soap12;	/* not serialized */
	bool updated;	/* not serialized */
	char *location;	/* not serialized */
	int redirs;	/* not serialized */
	SetOfString builtinTypeSet;	/* transient */	/* not serialized */
	SetOfString builtinElementSet;	/* transient */	/* not serialized */
	SetOfString builtinAttributeSet;	/* transient */	/* not serialized */
public:
	wsdl__definitions();	/* transient */
	wsdl__definitions(struct soap *_param_106, const char *_param_107, const char *_param_108);	/* transient */
	virtual ~wsdl__definitions();	/* transient */
	int get(struct soap *_param_109);	/* transient */
	int preprocess();	/* transient */
	int traverse();	/* transient */
	int read(int _param_110, char **_param_111);	/* transient */
	int read(const char *cwd, const char *_param_112);	/* transient */
	const char *sourceLocation();	/* transient */
	int error();	/* transient */
	void print_fault();	/* transient */
	void builtinType(const char *_param_113);	/* transient */
	void builtinTypes(const SetOfString &_param_114);	/* transient */
	void builtinElement(const char *_param_115);	/* transient */
	void builtinElements(const SetOfString &_param_116);	/* transient */
	void builtinAttribute(const char *_param_117);	/* transient */
	void builtinAttributes(const SetOfString &_param_118);	/* transient */
	const SetOfString &builtinTypes() const;	/* transient */	/* not serialized */
	const SetOfString &builtinElements() const;	/* transient */	/* not serialized */
	const SetOfString &builtinAttributes() const;	/* transient */	/* not serialized */
	friend ostream &operator<<(ostream &_param_119, const wsdl__definitions &_param_120);	/* transient */
	friend istream &operator>>(istream &_param_121, wsdl__definitions &_param_122);	/* transient */
public:
	virtual int soap_type() const { return 214; } /* = unique type id SOAP_TYPE_wsdl__definitions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
};
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (446)
/* SOAP Header: */
struct SOAP_ENV__Header
{
public:
	int soap_type() const { return 446; } /* = unique type id SOAP_TYPE_SOAP_ENV__Header */
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (447)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
public:
	int soap_type() const { return 447; } /* = unique type id SOAP_TYPE_SOAP_ENV__Code */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (449)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	char *__any;
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
public:
	int soap_type() const { return 449; } /* = unique type id SOAP_TYPE_SOAP_ENV__Detail */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (450)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
public:
	int soap_type() const { return 450; } /* = unique type id SOAP_TYPE_SOAP_ENV__Reason */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (451)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
public:
	int soap_type() const { return 451; } /* = unique type id SOAP_TYPE_SOAP_ENV__Fault */
};
#endif

#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (8)
typedef char *xsd__anyURI;
#endif

#ifndef SOAP_TYPE_xsd__ID
#define SOAP_TYPE_xsd__ID (9)
typedef char *xsd__ID;
#endif

#ifndef SOAP_TYPE_xsd__NCName
#define SOAP_TYPE_xsd__NCName (10)
typedef char *xsd__NCName;
#endif

#ifndef SOAP_TYPE_xsd__NMTOKEN
#define SOAP_TYPE_xsd__NMTOKEN (11)
typedef char *xsd__NMTOKEN;
#endif

#ifndef SOAP_TYPE_xsd__NMTOKENS
#define SOAP_TYPE_xsd__NMTOKENS (12)
typedef char *xsd__NMTOKENS;
#endif

#ifndef SOAP_TYPE_xsd__QName
#define SOAP_TYPE_xsd__QName (13)
typedef char *xsd__QName;
#endif

#ifndef SOAP_TYPE_xsd__string
#define SOAP_TYPE_xsd__string (14)
typedef char *xsd__string;
#endif

#ifndef SOAP_TYPE_xsd__boolean
#define SOAP_TYPE_xsd__boolean (16)
typedef bool xsd__boolean;
#endif

#ifndef SOAP_TYPE_xs__namespaceList
#define SOAP_TYPE_xs__namespaceList (75)
typedef char *xs__namespaceList;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


extern ostream &operator<<(ostream &o, const xs__schema &e);

extern istream &operator>>(istream &i, xs__schema &e);

extern ostream &operator<<(ostream &o, const wsdl__definitions &e);

extern istream &operator>>(istream &i, wsdl__definitions &e);

#endif

/* End of wsdlStub.h */
